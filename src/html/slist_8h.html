<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Collections-C: slist.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Collections-C
   </div>
   <div id="projectbrief">A library of generic container types.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">slist.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="common_8h_source.html">common.h</a>&quot;</code><br />
</div>
<p><a href="slist_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSNode.html">SNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSListIter.html">SListIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSListConf.html">SListConf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6fd7f38a3a21cc5f373be2e48cc0cf6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a6fd7f38a3a21cc5f373be2e48cc0cf6d">slist_conf_init</a> (<a class="el" href="structSListConf.html">SListConf</a> *conf)</td></tr>
<tr class="memdesc:a6fd7f38a3a21cc5f373be2e48cc0cf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the fields <a class="el" href="structSListConf.html">SListConf</a> struct to default values.  <a href="#a6fd7f38a3a21cc5f373be2e48cc0cf6d">More...</a><br /></td></tr>
<tr class="separator:a6fd7f38a3a21cc5f373be2e48cc0cf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d520f3ea8ddadd56af97e8a350fcd4"><td class="memItemLeft" align="right" valign="top">SList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a06d520f3ea8ddadd56af97e8a350fcd4">slist_new</a> (void)</td></tr>
<tr class="memdesc:a06d520f3ea8ddadd56af97e8a350fcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new empty list, or NULL if the memory allocation fails.  <a href="#a06d520f3ea8ddadd56af97e8a350fcd4">More...</a><br /></td></tr>
<tr class="separator:a06d520f3ea8ddadd56af97e8a350fcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79983f5d667038c94a784db069bd7a53"><td class="memItemLeft" align="right" valign="top">SList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a79983f5d667038c94a784db069bd7a53">slist_new_conf</a> (<a class="el" href="structSListConf.html">SListConf</a> *conf)</td></tr>
<tr class="memdesc:a79983f5d667038c94a784db069bd7a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new empty SList based on the specified <a class="el" href="structSListConf.html">SListConf</a> struct.  <a href="#a79983f5d667038c94a784db069bd7a53">More...</a><br /></td></tr>
<tr class="separator:a79983f5d667038c94a784db069bd7a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db19328f2c594f3929298d0c9b9362a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a4db19328f2c594f3929298d0c9b9362a">slist_destroy</a> (SList *list)</td></tr>
<tr class="memdesc:a4db19328f2c594f3929298d0c9b9362a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the list structure, but leaves the data that is holds intact.  <a href="#a4db19328f2c594f3929298d0c9b9362a">More...</a><br /></td></tr>
<tr class="separator:a4db19328f2c594f3929298d0c9b9362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5979c2a6d56dd22a97e9d0cf74116c5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a5979c2a6d56dd22a97e9d0cf74116c5c">slist_destroy_free</a> (SList *list)</td></tr>
<tr class="memdesc:a5979c2a6d56dd22a97e9d0cf74116c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the list structure along with all the data it holds.  <a href="#a5979c2a6d56dd22a97e9d0cf74116c5c">More...</a><br /></td></tr>
<tr class="separator:a5979c2a6d56dd22a97e9d0cf74116c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6b4ccd5fcff0724122285d9d1486be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a8a6b4ccd5fcff0724122285d9d1486be">slist_splice</a> (SList *list1, SList *list2)</td></tr>
<tr class="memdesc:a8a6b4ccd5fcff0724122285d9d1486be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices the two singly linked lists together by appending the second list to the first.  <a href="#a8a6b4ccd5fcff0724122285d9d1486be">More...</a><br /></td></tr>
<tr class="separator:a8a6b4ccd5fcff0724122285d9d1486be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c88e83bdc08eab7938e8478a942c174"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a1c88e83bdc08eab7938e8478a942c174">slist_splice_at</a> (SList *list1, SList *list2, size_t index)</td></tr>
<tr class="memdesc:a1c88e83bdc08eab7938e8478a942c174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices the two singly lists together at the specified index of the first list.  <a href="#a1c88e83bdc08eab7938e8478a942c174">More...</a><br /></td></tr>
<tr class="separator:a1c88e83bdc08eab7938e8478a942c174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851da222d472dfef9f4d34b4fabba842"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a851da222d472dfef9f4d34b4fabba842">slist_add</a> (SList *list, void *element)</td></tr>
<tr class="memdesc:a851da222d472dfef9f4d34b4fabba842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the list.  <a href="#a851da222d472dfef9f4d34b4fabba842">More...</a><br /></td></tr>
<tr class="separator:a851da222d472dfef9f4d34b4fabba842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c559d673af7ec847abef89c61d307a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a0c559d673af7ec847abef89c61d307a4">slist_add_at</a> (SList *list, void *element, size_t index)</td></tr>
<tr class="memdesc:a0c559d673af7ec847abef89c61d307a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the specified location in the list and shifts all subsequent elements by one.  <a href="#a0c559d673af7ec847abef89c61d307a4">More...</a><br /></td></tr>
<tr class="separator:a0c559d673af7ec847abef89c61d307a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a71541b944ec2945b6999f0d9fac8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#ac0a71541b944ec2945b6999f0d9fac8e">slist_add_all</a> (SList *list1, SList *list2)</td></tr>
<tr class="memdesc:ac0a71541b944ec2945b6999f0d9fac8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all elements from the second list to the first.  <a href="#ac0a71541b944ec2945b6999f0d9fac8e">More...</a><br /></td></tr>
<tr class="separator:ac0a71541b944ec2945b6999f0d9fac8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf1a2b40de8429bd47dededdf77641f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a8cf1a2b40de8429bd47dededdf77641f">slist_add_all_at</a> (SList *list1, SList *list2, size_t index)</td></tr>
<tr class="memdesc:a8cf1a2b40de8429bd47dededdf77641f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all element from the second list to the first at the specified position by shifting all subsequent elements by the size of the second list.  <a href="#a8cf1a2b40de8429bd47dededdf77641f">More...</a><br /></td></tr>
<tr class="separator:a8cf1a2b40de8429bd47dededdf77641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16763904e06a6e9e731aba2bb555cb7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a16763904e06a6e9e731aba2bb555cb7f">slist_add_first</a> (SList *list, void *element)</td></tr>
<tr class="memdesc:a16763904e06a6e9e731aba2bb555cb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a new element to the list (adds a new "head") making it the first element of the list.  <a href="#a16763904e06a6e9e731aba2bb555cb7f">More...</a><br /></td></tr>
<tr class="separator:a16763904e06a6e9e731aba2bb555cb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cf2a46a7e8dc2777c37ed823125f0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a06cf2a46a7e8dc2777c37ed823125f0a">slist_add_last</a> (SList *list, void *element)</td></tr>
<tr class="memdesc:a06cf2a46a7e8dc2777c37ed823125f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the list (adds a new "tail") making it the last element of the list.  <a href="#a06cf2a46a7e8dc2777c37ed823125f0a">More...</a><br /></td></tr>
<tr class="separator:a06cf2a46a7e8dc2777c37ed823125f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878ae9b937df55927e1cb166fb703ea9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a878ae9b937df55927e1cb166fb703ea9">slist_remove</a> (SList *list, void *element)</td></tr>
<tr class="memdesc:a878ae9b937df55927e1cb166fb703ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the first occurrence of the element from the specified list.  <a href="#a878ae9b937df55927e1cb166fb703ea9">More...</a><br /></td></tr>
<tr class="separator:a878ae9b937df55927e1cb166fb703ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb6c3863501b4db8d1beb81a639ba4b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a0fb6c3863501b4db8d1beb81a639ba4b">slist_remove_first</a> (SList *list)</td></tr>
<tr class="memdesc:a0fb6c3863501b4db8d1beb81a639ba4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the first (head) element of the list.  <a href="#a0fb6c3863501b4db8d1beb81a639ba4b">More...</a><br /></td></tr>
<tr class="separator:a0fb6c3863501b4db8d1beb81a639ba4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0be2784b683b5f83202890c39b10a8b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#ac0be2784b683b5f83202890c39b10a8b">slist_remove_last</a> (SList *list)</td></tr>
<tr class="memdesc:ac0be2784b683b5f83202890c39b10a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the last (tail) element of the list.  <a href="#ac0be2784b683b5f83202890c39b10a8b">More...</a><br /></td></tr>
<tr class="separator:ac0be2784b683b5f83202890c39b10a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7148cf60391d9049fec991b8293d2fde"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a7148cf60391d9049fec991b8293d2fde">slist_remove_at</a> (SList *list, size_t index)</td></tr>
<tr class="memdesc:a7148cf60391d9049fec991b8293d2fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the element at the specified index.  <a href="#a7148cf60391d9049fec991b8293d2fde">More...</a><br /></td></tr>
<tr class="separator:a7148cf60391d9049fec991b8293d2fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b8dbe44b5b51d13772d9d807fa21f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a74b8dbe44b5b51d13772d9d807fa21f0">slist_remove_all</a> (SList *list)</td></tr>
<tr class="memdesc:a74b8dbe44b5b51d13772d9d807fa21f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the specified list.  <a href="#a74b8dbe44b5b51d13772d9d807fa21f0">More...</a><br /></td></tr>
<tr class="separator:a74b8dbe44b5b51d13772d9d807fa21f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8199d6ac4c09d096f0103ad665205cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#af8199d6ac4c09d096f0103ad665205cb">slist_remove_all_free</a> (SList *list)</td></tr>
<tr class="memdesc:af8199d6ac4c09d096f0103ad665205cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and frees all the elements from the specified list.  <a href="#af8199d6ac4c09d096f0103ad665205cb">More...</a><br /></td></tr>
<tr class="separator:af8199d6ac4c09d096f0103ad665205cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fc5fb966aae09566b9f7636337ce39"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#ab5fc5fb966aae09566b9f7636337ce39">slist_get</a> (SList *list, size_t index)</td></tr>
<tr class="memdesc:ab5fc5fb966aae09566b9f7636337ce39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list element from the specified index.  <a href="#ab5fc5fb966aae09566b9f7636337ce39">More...</a><br /></td></tr>
<tr class="separator:ab5fc5fb966aae09566b9f7636337ce39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8fdcd7ecb2b67feaf61378ff534d2e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a7d8fdcd7ecb2b67feaf61378ff534d2e">slist_get_first</a> (SList *list)</td></tr>
<tr class="memdesc:a7d8fdcd7ecb2b67feaf61378ff534d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element from the specified list, or NULL if the list is empty.  <a href="#a7d8fdcd7ecb2b67feaf61378ff534d2e">More...</a><br /></td></tr>
<tr class="separator:a7d8fdcd7ecb2b67feaf61378ff534d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bd598fc66effc0353c942090e70c89"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a35bd598fc66effc0353c942090e70c89">slist_get_last</a> (SList *list)</td></tr>
<tr class="memdesc:a35bd598fc66effc0353c942090e70c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last element from the specified list.  <a href="#a35bd598fc66effc0353c942090e70c89">More...</a><br /></td></tr>
<tr class="separator:a35bd598fc66effc0353c942090e70c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff39357ded2fd88b8dba1bbdec51355"><td class="memItemLeft" align="right" valign="top">SList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#abff39357ded2fd88b8dba1bbdec51355">slist_sublist</a> (SList *list, size_t from, size_t to)</td></tr>
<tr class="memdesc:abff39357ded2fd88b8dba1bbdec51355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sublist of the specified list.  <a href="#abff39357ded2fd88b8dba1bbdec51355">More...</a><br /></td></tr>
<tr class="separator:abff39357ded2fd88b8dba1bbdec51355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca22bd21860a475937d5aa2d77c5b75e"><td class="memItemLeft" align="right" valign="top">SList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#aca22bd21860a475937d5aa2d77c5b75e">slist_copy_shallow</a> (SList *list)</td></tr>
<tr class="memdesc:aca22bd21860a475937d5aa2d77c5b75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shallow copy of the specified list.  <a href="#aca22bd21860a475937d5aa2d77c5b75e">More...</a><br /></td></tr>
<tr class="separator:aca22bd21860a475937d5aa2d77c5b75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8344da53d45d915445b765f4426c0a6f"><td class="memItemLeft" align="right" valign="top">SList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a8344da53d45d915445b765f4426c0a6f">slist_copy_deep</a> (SList *list, void *(*cp)(void *))</td></tr>
<tr class="memdesc:a8344da53d45d915445b765f4426c0a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a deep copy of the specified list.  <a href="#a8344da53d45d915445b765f4426c0a6f">More...</a><br /></td></tr>
<tr class="separator:a8344da53d45d915445b765f4426c0a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62c6e1ae0c20edc1fcf9c34f3dd1429"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#af62c6e1ae0c20edc1fcf9c34f3dd1429">slist_replace_at</a> (SList *list, void *element, size_t index)</td></tr>
<tr class="memdesc:af62c6e1ae0c20edc1fcf9c34f3dd1429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces an element at the specified location and returns the old element.  <a href="#af62c6e1ae0c20edc1fcf9c34f3dd1429">More...</a><br /></td></tr>
<tr class="separator:af62c6e1ae0c20edc1fcf9c34f3dd1429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150127e2afc03e8903391d7d04dd565f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a150127e2afc03e8903391d7d04dd565f">slist_contains</a> (SList *list, void *element)</td></tr>
<tr class="memdesc:a150127e2afc03e8903391d7d04dd565f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an integer representing the number of occurrences of the specified element within the list.  <a href="#a150127e2afc03e8903391d7d04dd565f">More...</a><br /></td></tr>
<tr class="separator:a150127e2afc03e8903391d7d04dd565f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa431ef43975c47a45e98117ebd19a5d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#aa431ef43975c47a45e98117ebd19a5d8">slist_index_of</a> (SList *list, void *element)</td></tr>
<tr class="memdesc:aa431ef43975c47a45e98117ebd19a5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the specified element, or <code>NO_SUCH_INDEX</code> if the element is not found.  <a href="#aa431ef43975c47a45e98117ebd19a5d8">More...</a><br /></td></tr>
<tr class="separator:aa431ef43975c47a45e98117ebd19a5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9274a5a2fd2b0220ee86dd80bfb89f"><td class="memItemLeft" align="right" valign="top">void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a8d9274a5a2fd2b0220ee86dd80bfb89f">slist_to_array</a> (SList *list)</td></tr>
<tr class="memdesc:a8d9274a5a2fd2b0220ee86dd80bfb89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array representation of the specified list.  <a href="#a8d9274a5a2fd2b0220ee86dd80bfb89f">More...</a><br /></td></tr>
<tr class="separator:a8d9274a5a2fd2b0220ee86dd80bfb89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b7de5c084de5dfb376578398440d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#ad4b7de5c084de5dfb376578398440d38">slist_reverse</a> (SList *list)</td></tr>
<tr class="memdesc:ad4b7de5c084de5dfb376578398440d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of elements in the specified list.  <a href="#ad4b7de5c084de5dfb376578398440d38">More...</a><br /></td></tr>
<tr class="separator:ad4b7de5c084de5dfb376578398440d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d346ca9e40b07b40a650d168c782ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a41d346ca9e40b07b40a650d168c782ee">slist_sort</a> (SList *list, int(*cmp)(void const *, void const *))</td></tr>
<tr class="separator:a41d346ca9e40b07b40a650d168c782ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632b04663da986bf2d7fe6d8b9a7a4ef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a632b04663da986bf2d7fe6d8b9a7a4ef">slist_size</a> (SList *list)</td></tr>
<tr class="memdesc:a632b04663da986bf2d7fe6d8b9a7a4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the specified list.  <a href="#a632b04663da986bf2d7fe6d8b9a7a4ef">More...</a><br /></td></tr>
<tr class="separator:a632b04663da986bf2d7fe6d8b9a7a4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca0d7f112c772fb5455e9f2a2d01264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a3ca0d7f112c772fb5455e9f2a2d01264">slist_foreach</a> (SList *list, void(*op)(void *))</td></tr>
<tr class="memdesc:a3ca0d7f112c772fb5455e9f2a2d01264"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 'foreach loop' function that invokes the specified function on each element in the list.  <a href="#a3ca0d7f112c772fb5455e9f2a2d01264">More...</a><br /></td></tr>
<tr class="separator:a3ca0d7f112c772fb5455e9f2a2d01264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83827924f490d2321863705527e555fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a83827924f490d2321863705527e555fc">slist_iter_init</a> (<a class="el" href="structSListIter.html">SListIter</a> *iter, SList *list)</td></tr>
<tr class="memdesc:a83827924f490d2321863705527e555fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the iterator.  <a href="#a83827924f490d2321863705527e555fc">More...</a><br /></td></tr>
<tr class="separator:a83827924f490d2321863705527e555fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e93e4ef5869bf0875e440f48e06a6e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a42e93e4ef5869bf0875e440f48e06a6e">slist_iter_remove</a> (<a class="el" href="structSListIter.html">SListIter</a> *iter)</td></tr>
<tr class="memdesc:a42e93e4ef5869bf0875e440f48e06a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the last returned element by <code><a class="el" href="slist_8c.html#a4fb11ce17c595b1d33d3ccba49593535" title="Returns the next element in the sequence and advances the iterator. ">slist_iter_next()</a> </code> function without invalidating the iterator.  <a href="#a42e93e4ef5869bf0875e440f48e06a6e">More...</a><br /></td></tr>
<tr class="separator:a42e93e4ef5869bf0875e440f48e06a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54420d7bb727ae630d15beed6380ee75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a54420d7bb727ae630d15beed6380ee75">slist_iter_add</a> (<a class="el" href="structSListIter.html">SListIter</a> *iter, void *element)</td></tr>
<tr class="memdesc:a54420d7bb727ae630d15beed6380ee75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the list after the last returned element by <code><a class="el" href="slist_8c.html#a4fb11ce17c595b1d33d3ccba49593535" title="Returns the next element in the sequence and advances the iterator. ">slist_iter_next()</a></code> function without invalidating the iterator.  <a href="#a54420d7bb727ae630d15beed6380ee75">More...</a><br /></td></tr>
<tr class="separator:a54420d7bb727ae630d15beed6380ee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3fc50bc738fdcfb2a885361c272bcb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a9e3fc50bc738fdcfb2a885361c272bcb">slist_iter_replace</a> (<a class="el" href="structSListIter.html">SListIter</a> *iter, void *element)</td></tr>
<tr class="memdesc:a9e3fc50bc738fdcfb2a885361c272bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the last returned element by <code><a class="el" href="slist_8c.html#a4fb11ce17c595b1d33d3ccba49593535" title="Returns the next element in the sequence and advances the iterator. ">slist_iter_next()</a></code> with the specified element.  <a href="#a9e3fc50bc738fdcfb2a885361c272bcb">More...</a><br /></td></tr>
<tr class="separator:a9e3fc50bc738fdcfb2a885361c272bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb11ce17c595b1d33d3ccba49593535"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a4fb11ce17c595b1d33d3ccba49593535">slist_iter_next</a> (<a class="el" href="structSListIter.html">SListIter</a> *iter)</td></tr>
<tr class="memdesc:a4fb11ce17c595b1d33d3ccba49593535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next element in the sequence and advances the iterator.  <a href="#a4fb11ce17c595b1d33d3ccba49593535">More...</a><br /></td></tr>
<tr class="separator:a4fb11ce17c595b1d33d3ccba49593535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2e0816cf6e56d2138964ff6bbadca2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a0d2e0816cf6e56d2138964ff6bbadca2">slist_iter_index</a> (<a class="el" href="structSListIter.html">SListIter</a> *iter)</td></tr>
<tr class="memdesc:a0d2e0816cf6e56d2138964ff6bbadca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return s the index of the last returned element by <code><a class="el" href="slist_8c.html#a4fb11ce17c595b1d33d3ccba49593535" title="Returns the next element in the sequence and advances the iterator. ">slist_iter_next()</a> </code>.  <a href="#a0d2e0816cf6e56d2138964ff6bbadca2">More...</a><br /></td></tr>
<tr class="separator:a0d2e0816cf6e56d2138964ff6bbadca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386fb815e95a065a5e21f52354cc9b30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a386fb815e95a065a5e21f52354cc9b30">slist_iter_has_next</a> (<a class="el" href="structSListIter.html">SListIter</a> *iter)</td></tr>
<tr class="memdesc:a386fb815e95a065a5e21f52354cc9b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether or not the iterator has reached the end of the list.  <a href="#a386fb815e95a065a5e21f52354cc9b30">More...</a><br /></td></tr>
<tr class="separator:a386fb815e95a065a5e21f52354cc9b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a851da222d472dfef9f4d34b4fabba842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_add </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the list. </p>
<p>The element is appended to the list making it the last element of the list. This function returns false if the memory allocation for the new element has fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the element was successfully added to the list. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0a71541b944ec2945b6999f0d9fac8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_add_all </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all elements from the second list to the first. </p>
<p>The elements from the second list are added after the last element of the first list. This function returns false if no elements were added to the first list. This could be the case if either the second list is empty or if the memory allocation for the element that are being added fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list1</td><td>the list to which the elements are being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list2</td><td>the list from which the elements are being taken.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the elements were successfully added </dd></dl>

</div>
</div>
<a class="anchor" id="a8cf1a2b40de8429bd47dededdf77641f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_add_all_at </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all element from the second list to the first at the specified position by shifting all subsequent elements by the size of the second list. </p>
<p>The index must be within the range of the list. This function returns false if no elements were added to the first list. This could be the case if either the second list is empty or if the memory allocation for the elements being added fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list1</td><td>the list to which the elements are being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>list from which the elements are being taken </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>position in the first list at which the elements should be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the elements were successfully added </dd></dl>

</div>
</div>
<a class="anchor" id="a0c559d673af7ec847abef89c61d307a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_add_at </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the specified location in the list and shifts all subsequent elements by one. </p>
<p>This operation cannot be performed on an empty list. The index at which the new element is being added must be within the bounds of the list. This function returns false if either the index is out of bounds, or if the memory allocation for the new element fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list to which this element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the position in the list at which the new element is being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the element was successfully added to the list </dd></dl>

</div>
</div>
<a class="anchor" id="a16763904e06a6e9e731aba2bb555cb7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_add_first </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepends a new element to the list (adds a new "head") making it the first element of the list. </p>
<p>This function returns false if the memory allocation for the new element fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the element was successfully added to the list </dd></dl>

</div>
</div>
<a class="anchor" id="a06cf2a46a7e8dc2777c37ed823125f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_add_last </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a new element to the list (adds a new "tail") making it the last element of the list. </p>
<p>This function returns false if the memory allocation for the new element fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the element was successfully added to the list </dd></dl>

</div>
</div>
<a class="anchor" id="a6fd7f38a3a21cc5f373be2e48cc0cf6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slist_conf_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSListConf.html">SListConf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the fields <a class="el" href="structSListConf.html">SListConf</a> struct to default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>the <a class="el" href="structSListConf.html">SListConf</a> struct that is being initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a150127e2afc03e8903391d7d04dd565f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t slist_contains </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an integer representing the number of occurrences of the specified element within the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list on which the search is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being looked for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of found matches </dd></dl>

</div>
</div>
<a class="anchor" id="a8344da53d45d915445b765f4426c0a6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SList* slist_copy_deep </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a deep copy of the specified list. </p>
<p>This function copies the structure of the list along with all the data it holds. The element copying is done through the specified copy function that should return a pointer to the copy of the element passed to it.</p>
<dl class="section note"><dt>Note</dt><dd>The new list is allocated using the original lists allocators and also inherits the configuration of the original list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list to be copied [in] cp the copy function that should return a pointer to the copy of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deep copy of the list </dd></dl>

</div>
</div>
<a class="anchor" id="aca22bd21860a475937d5aa2d77c5b75e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SList* slist_copy_shallow </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a shallow copy of the specified list. </p>
<p>A shallow copy is a copy of the list structure. This operation does not copy the actual data that this list holds.</p>
<dl class="section note"><dt>Note</dt><dd>The new list is allocated using the original lists allocators and also inherits the configuration of the original list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shallow copy of the list </dd></dl>

</div>
</div>
<a class="anchor" id="a4db19328f2c594f3929298d0c9b9362a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_destroy </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the list structure, but leaves the data that is holds intact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>a list to destroy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a5979c2a6d56dd22a97e9d0cf74116c5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_destroy_free </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the list structure along with all the data it holds. </p>
<p>This function returns true if the operation was successful, or false if the list was already empty.</p>
<p>This function should not be called on a list that has some of it's elements allocated on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a3ca0d7f112c772fb5455e9f2a2d01264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slist_foreach </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 'foreach loop' function that invokes the specified function on each element in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>the operation function that is to be invoked on each list element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5fc5fb966aae09566b9f7636337ce39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_get </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list element from the specified index. </p>
<p>In case the index is out of bounds, this function returns NULL instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list from which the element is being returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of a list element being returned. The index must be within the bound of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list element at the specified index. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d8fdcd7ecb2b67feaf61378ff534d2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_get_first </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first element from the specified list, or NULL if the list is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list whose first element is being returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first element of the list, or NULL in case the list is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a35bd598fc66effc0353c942090e70c89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_get_last </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last element from the specified list. </p>
<p>or NULL if the list is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list whose last element is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last element of the list, or NULL in case the list is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aa431ef43975c47a45e98117ebd19a5d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t slist_index_of </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the specified element, or <code>NO_SUCH_INDEX</code> if the element is not found. </p>
<p>The returned index is the index of the first occurrence of the element starting from the beginning of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list on which this operation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element whose index is being looked up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the specified element or <code>NO_SUCH_INDEX</code> if the element is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a54420d7bb727ae630d15beed6380ee75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_iter_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSListIter.html">SListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the list after the last returned element by <code><a class="el" href="slist_8c.html#a4fb11ce17c595b1d33d3ccba49593535" title="Returns the next element in the sequence and advances the iterator. ">slist_iter_next()</a></code> function without invalidating the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element being added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a386fb815e95a065a5e21f52354cc9b30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_iter_has_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSListIter.html">SListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether or not the iterator has reached the end of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>iterator whose position is being checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are more element to be iterated over, or false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a0d2e0816cf6e56d2138964ff6bbadca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t slist_iter_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSListIter.html">SListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return s the index of the last returned element by <code><a class="el" href="slist_8c.html#a4fb11ce17c595b1d33d3ccba49593535" title="Returns the next element in the sequence and advances the iterator. ">slist_iter_next()</a> </code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index </dd></dl>

</div>
</div>
<a class="anchor" id="a83827924f490d2321863705527e555fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slist_iter_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSListIter.html">SListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator that is being initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the slist to iterate over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fb11ce17c595b1d33d3ccba49593535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_iter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSListIter.html">SListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next element in the sequence and advances the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator that is being advanced</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next element in the sequence </dd></dl>

</div>
</div>
<a class="anchor" id="a42e93e4ef5869bf0875e440f48e06a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_iter_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSListIter.html">SListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the last returned element by <code><a class="el" href="slist_8c.html#a4fb11ce17c595b1d33d3ccba49593535" title="Returns the next element in the sequence and advances the iterator. ">slist_iter_next()</a> </code> function without invalidating the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element </dd></dl>

</div>
</div>
<a class="anchor" id="a9e3fc50bc738fdcfb2a885361c272bcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_iter_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSListIter.html">SListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the last returned element by <code><a class="el" href="slist_8c.html#a4fb11ce17c595b1d33d3ccba49593535" title="Returns the next element in the sequence and advances the iterator. ">slist_iter_next()</a></code> with the specified element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being pefromed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the replacement element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the replaced element </dd></dl>

</div>
</div>
<a class="anchor" id="a06d520f3ea8ddadd56af97e8a350fcd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SList* slist_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new empty list, or NULL if the memory allocation fails. </p>
<dl class="section return"><dt>Returns</dt><dd>a new list, or NULL if the memory allocation fails </dd></dl>

</div>
</div>
<a class="anchor" id="a79983f5d667038c94a784db069bd7a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SList* slist_new_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSListConf.html">SListConf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new empty SList based on the specified <a class="el" href="structSListConf.html">SListConf</a> struct. </p>
<p>The SList is allocated using the allocators specified in the <a class="el" href="structSListConf.html">SListConf</a> struct. THe allocation may fail if the underlying allocator fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>SList configuration. All fields must be initialized to appropriate values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new SList if the allocation was successful, or NULL if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a878ae9b937df55927e1cb166fb703ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_remove </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the first occurrence of the element from the specified list. </p>
<p>If the element if not a part of the list, NULL is returned instead. NULL may also be returned if the removed element was NULL. Calling <code> <a class="el" href="slist_8c.html#a150127e2afc03e8903391d7d04dd565f" title="Returns an integer representing the number of occurrences of the specified element within the list...">slist_contains()</a></code> before this function can resolve the ambiguity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>a list from which the element is being removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element </dd></dl>

</div>
</div>
<a class="anchor" id="a74b8dbe44b5b51d13772d9d807fa21f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_remove_all </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the specified list. </p>
<p>This function returns true if at least one element was removed, or false if the list was already empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which all elements are being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful and at least one element was removed, or false if the list was already empty </dd></dl>

</div>
</div>
<a class="anchor" id="af8199d6ac4c09d096f0103ad665205cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_remove_all_free </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and frees all the elements from the specified list. </p>
<p>This function returns true if at least one element was removed and freed, or false if the list was already empty.</p>
<dl class="section note"><dt>Note</dt><dd>This function should not be called on a list that has some of it's elements allocated on the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which all the elements are being removed and freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful and at least one element was removed or false if the list is already empty </dd></dl>

</div>
</div>
<a class="anchor" id="a7148cf60391d9049fec991b8293d2fde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_remove_at </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the element at the specified index. </p>
<p>The index must be within the bounds of the list. In case the index is out of bounds this function returns NULL. NULL may also be returned if the element at the specified index is actually NULL. Calling <code><a class="el" href="slist_8c.html#a150127e2afc03e8903391d7d04dd565f" title="Returns an integer representing the number of occurrences of the specified element within the list...">slist_contains()</a></code> before this function can resolve this ambiguity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which the element is being removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of the element is being removed. Must be be within the index range of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element, or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a0fb6c3863501b4db8d1beb81a639ba4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_remove_first </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the first (head) element of the list. </p>
<p>If the list is empty, NULL is returned instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which the first element is being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element, or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ac0be2784b683b5f83202890c39b10a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_remove_last </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the last (tail) element of the list. </p>
<p>If the list is empty, NULL is returned instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which the last element is being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element, or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="af62c6e1ae0c20edc1fcf9c34f3dd1429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* slist_replace_at </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces an element at the specified location and returns the old element. </p>
<p>The specified index must be within the bounds of the list. This function returns false if the specified index is out of range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list on which this operation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the replacement element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of the element being replaced</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the replaced element </dd></dl>

</div>
</div>
<a class="anchor" id="ad4b7de5c084de5dfb376578398440d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slist_reverse </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the order of elements in the specified list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list that is being reversed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a632b04663da986bf2d7fe6d8b9a7a4ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t slist_size </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the specified list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>whose size is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the elements contained in the specified list </dd></dl>

</div>
</div>
<a class="anchor" id="a41d346ca9e40b07b40a650d168c782ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slist_sort </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void const *, void const *)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a6b4ccd5fcff0724122285d9d1486be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_splice </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splices the two singly linked lists together by appending the second list to the first. </p>
<p>This function moves all the elements from the second list into the first list, leaving the second list empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list1</td><td>The consumer list to which the elements are moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list2</td><td>The producer list from which the elements are moved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a1c88e83bdc08eab7938e8478a942c174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool slist_splice_at </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splices the two singly lists together at the specified index of the first list. </p>
<p>this function moves all the elements from the second list into the first list at the position specified by the <code>index</code> parameter. After this operation the second list will be left empty. This function returns false if the second list is already empty or if the specified index is out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list1</td><td>the consumer list to which the elements are moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list2</td><td>the producer list from which the elements are moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the first list after which the elements from the second list should be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if at least one element was moved from the second list </dd></dl>

</div>
</div>
<a class="anchor" id="abff39357ded2fd88b8dba1bbdec51355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SList* slist_sublist </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sublist of the specified list. </p>
<p>The returned sublist contains all the elements from the list that are contained between the two indices including the elements at the indices. For example if a list contains 5 elements [5, 6, 7, 8, 9], a sublist from index 1 to 3 will will be a new list of length 3, containing [6, 7, 8]. The returned sublist is only a copy of the original lists structure, meaning the data it points to is not copied.</p>
<dl class="section note"><dt>Note</dt><dd>The sublist is allocated using the original lists allocators and also inherits the configuration of the original list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which the sublist is taken </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The beginning index, ie., the first element to be included. Must be a positive integer and may not exceed the list size or the end index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The ending index, ie., the last element to be included. Must be a positive integer no greater that the list size and no smaller that the beginning index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new sublist or NULL if any of the indices are out of list bounds </dd></dl>

</div>
</div>
<a class="anchor" id="a8d9274a5a2fd2b0220ee86dd80bfb89f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void** slist_to_array </td>
          <td>(</td>
          <td class="paramtype">SList *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array representation of the specified list. </p>
<p>None of the elements are copied into the array and thus any modification of the elements within the array will affect the list elements as well. The size of the returned array is the same as the size of the list from which the array was constructed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list on which this operation is being performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array representation of the specified list </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 11 2015 14:07:07 for Collections-C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
