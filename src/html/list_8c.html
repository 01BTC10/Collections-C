<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Collections-C: list.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Collections-C
   </div>
   <div id="projectbrief">A library of generic container types.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">list.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="list_8h_source.html">list.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlist__s.html">List</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A doubly linked list.  <a href="structlist__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83f3aebf1e7382ad294ce807cf798b7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a83f3aebf1e7382ad294ce807cf798b7e">list_conf_init</a> (<a class="el" href="structListConf.html">ListConf</a> *conf)</td></tr>
<tr class="memdesc:a83f3aebf1e7382ad294ce807cf798b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the fields of the <a class="el" href="structListConf.html">ListConf</a> struct to default values.  <a href="#a83f3aebf1e7382ad294ce807cf798b7e">More...</a><br /></td></tr>
<tr class="separator:a83f3aebf1e7382ad294ce807cf798b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4014f5a2de9e5167f343fb75092adae0"><td class="memItemLeft" align="right" valign="top">List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a4014f5a2de9e5167f343fb75092adae0">list_new</a> ()</td></tr>
<tr class="memdesc:a4014f5a2de9e5167f343fb75092adae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new empty list, or NULL if the memory allocation fails.  <a href="#a4014f5a2de9e5167f343fb75092adae0">More...</a><br /></td></tr>
<tr class="separator:a4014f5a2de9e5167f343fb75092adae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0e7a284d7d3a024e88cec289ceeb7e"><td class="memItemLeft" align="right" valign="top">List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a7d0e7a284d7d3a024e88cec289ceeb7e">list_new_conf</a> (<a class="el" href="structListConf.html">ListConf</a> *conf)</td></tr>
<tr class="memdesc:a7d0e7a284d7d3a024e88cec289ceeb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new empty list based on the specified <a class="el" href="structListConf.html">ListConf</a> struct.  <a href="#a7d0e7a284d7d3a024e88cec289ceeb7e">More...</a><br /></td></tr>
<tr class="separator:a7d0e7a284d7d3a024e88cec289ceeb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087e11bba621f27c4cfbb437046d076a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a087e11bba621f27c4cfbb437046d076a">list_destroy</a> (List *list)</td></tr>
<tr class="memdesc:a087e11bba621f27c4cfbb437046d076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the list structure, but leaves the data that is holds intact.  <a href="#a087e11bba621f27c4cfbb437046d076a">More...</a><br /></td></tr>
<tr class="separator:a087e11bba621f27c4cfbb437046d076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba20a463ce16f97484b02caadf0f006e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#aba20a463ce16f97484b02caadf0f006e">list_destroy_free</a> (List *list)</td></tr>
<tr class="memdesc:aba20a463ce16f97484b02caadf0f006e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the list structure along with all the data it holds.  <a href="#aba20a463ce16f97484b02caadf0f006e">More...</a><br /></td></tr>
<tr class="separator:aba20a463ce16f97484b02caadf0f006e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac376012b2b46fc6a7028be689651bbdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#ac376012b2b46fc6a7028be689651bbdb">list_add</a> (List *list, void *element)</td></tr>
<tr class="memdesc:ac376012b2b46fc6a7028be689651bbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the list.  <a href="#ac376012b2b46fc6a7028be689651bbdb">More...</a><br /></td></tr>
<tr class="separator:ac376012b2b46fc6a7028be689651bbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7917a459179294d7031b8b4caf3f3d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#ab7917a459179294d7031b8b4caf3f3d9">list_add_first</a> (List *list, void *element)</td></tr>
<tr class="memdesc:ab7917a459179294d7031b8b4caf3f3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a new element to the list (adds a new "head") making it the first element of the list.  <a href="#ab7917a459179294d7031b8b4caf3f3d9">More...</a><br /></td></tr>
<tr class="separator:ab7917a459179294d7031b8b4caf3f3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d717433bcd6de26b57146a90c8f2547"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a1d717433bcd6de26b57146a90c8f2547">list_add_last</a> (List *list, void *element)</td></tr>
<tr class="memdesc:a1d717433bcd6de26b57146a90c8f2547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the list (adds an new "tail") making it the last element of the list.  <a href="#a1d717433bcd6de26b57146a90c8f2547">More...</a><br /></td></tr>
<tr class="separator:a1d717433bcd6de26b57146a90c8f2547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff0c7f6b50c7521cad56d838ba98e42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#afff0c7f6b50c7521cad56d838ba98e42">list_add_at</a> (List *list, void *element, size_t index)</td></tr>
<tr class="memdesc:afff0c7f6b50c7521cad56d838ba98e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the specified location in the list and shifts all subsequent elements by one.  <a href="#afff0c7f6b50c7521cad56d838ba98e42">More...</a><br /></td></tr>
<tr class="separator:afff0c7f6b50c7521cad56d838ba98e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b18d4d0dfd9be1953e3ccfa55eb5bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a62b18d4d0dfd9be1953e3ccfa55eb5bc">list_add_all</a> (List *list1, List *list2)</td></tr>
<tr class="memdesc:a62b18d4d0dfd9be1953e3ccfa55eb5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all elements from the second list to the first.  <a href="#a62b18d4d0dfd9be1953e3ccfa55eb5bc">More...</a><br /></td></tr>
<tr class="separator:a62b18d4d0dfd9be1953e3ccfa55eb5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac348bfce6082d5d4edcd1d53a5991589"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#ac348bfce6082d5d4edcd1d53a5991589">list_add_all_at</a> (List *list1, List *list2, size_t index)</td></tr>
<tr class="memdesc:ac348bfce6082d5d4edcd1d53a5991589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all elements from the second list to the first at the specified position by shifting all subsequent elements by the size of the second list.  <a href="#ac348bfce6082d5d4edcd1d53a5991589">More...</a><br /></td></tr>
<tr class="separator:ac348bfce6082d5d4edcd1d53a5991589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f879e3662fa0d03e8f89a178b5c3e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#af5f879e3662fa0d03e8f89a178b5c3e9">list_splice</a> (List *list1, List *list2)</td></tr>
<tr class="memdesc:af5f879e3662fa0d03e8f89a178b5c3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices the two doubly linked lists together by appending the second list to the first.  <a href="#af5f879e3662fa0d03e8f89a178b5c3e9">More...</a><br /></td></tr>
<tr class="separator:af5f879e3662fa0d03e8f89a178b5c3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab721694878df9d5c20de4267eb623e40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#ab721694878df9d5c20de4267eb623e40">list_splice_at</a> (List *list1, List *list2, size_t index)</td></tr>
<tr class="memdesc:ab721694878df9d5c20de4267eb623e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices the two lists together at the specified index of the first list.  <a href="#ab721694878df9d5c20de4267eb623e40">More...</a><br /></td></tr>
<tr class="separator:ab721694878df9d5c20de4267eb623e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6401a554f3c550f04d83aa4c3db946"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#aed6401a554f3c550f04d83aa4c3db946">list_remove</a> (List *list, void *element)</td></tr>
<tr class="memdesc:aed6401a554f3c550f04d83aa4c3db946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the first occurrence of the element from the specified list.  <a href="#aed6401a554f3c550f04d83aa4c3db946">More...</a><br /></td></tr>
<tr class="separator:aed6401a554f3c550f04d83aa4c3db946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3ae97b756103f185a98f920b680759"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#aae3ae97b756103f185a98f920b680759">list_remove_at</a> (List *list, size_t index)</td></tr>
<tr class="memdesc:aae3ae97b756103f185a98f920b680759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the element at the specified index.  <a href="#aae3ae97b756103f185a98f920b680759">More...</a><br /></td></tr>
<tr class="separator:aae3ae97b756103f185a98f920b680759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe34a6b6762d37e9b1c1246a97e387b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#aefe34a6b6762d37e9b1c1246a97e387b">list_remove_first</a> (List *list)</td></tr>
<tr class="memdesc:aefe34a6b6762d37e9b1c1246a97e387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the first (head) element of the list.  <a href="#aefe34a6b6762d37e9b1c1246a97e387b">More...</a><br /></td></tr>
<tr class="separator:aefe34a6b6762d37e9b1c1246a97e387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8cde03c75d840976c92fc2fbf36c0e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a6e8cde03c75d840976c92fc2fbf36c0e">list_remove_last</a> (List *list)</td></tr>
<tr class="memdesc:a6e8cde03c75d840976c92fc2fbf36c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the first (tail) element of the list.  <a href="#a6e8cde03c75d840976c92fc2fbf36c0e">More...</a><br /></td></tr>
<tr class="separator:a6e8cde03c75d840976c92fc2fbf36c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580ac58766c66691c082405ad769690c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a580ac58766c66691c082405ad769690c">list_remove_all</a> (List *list)</td></tr>
<tr class="memdesc:a580ac58766c66691c082405ad769690c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the specified list.  <a href="#a580ac58766c66691c082405ad769690c">More...</a><br /></td></tr>
<tr class="separator:a580ac58766c66691c082405ad769690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fbfc5b25677a607742b4b824c7ee3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a29fbfc5b25677a607742b4b824c7ee3f">list_remove_all_free</a> (List *list)</td></tr>
<tr class="memdesc:a29fbfc5b25677a607742b4b824c7ee3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and frees all the elements from the specified list.  <a href="#a29fbfc5b25677a607742b4b824c7ee3f">More...</a><br /></td></tr>
<tr class="separator:a29fbfc5b25677a607742b4b824c7ee3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f3e736f60d9adf26084658bb32ebe5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a39f3e736f60d9adf26084658bb32ebe5">list_replace_at</a> (List *list, void *element, size_t index)</td></tr>
<tr class="memdesc:a39f3e736f60d9adf26084658bb32ebe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces an element at the specified location and returns the old element.  <a href="#a39f3e736f60d9adf26084658bb32ebe5">More...</a><br /></td></tr>
<tr class="separator:a39f3e736f60d9adf26084658bb32ebe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e74fc7780605306269a5c71ab674b4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#ad8e74fc7780605306269a5c71ab674b4">list_get_first</a> (List *list)</td></tr>
<tr class="memdesc:ad8e74fc7780605306269a5c71ab674b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element from the specified list, or NULL if the list is empty.  <a href="#ad8e74fc7780605306269a5c71ab674b4">More...</a><br /></td></tr>
<tr class="separator:ad8e74fc7780605306269a5c71ab674b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6168acee09844533c26cf2889a8dc361"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a6168acee09844533c26cf2889a8dc361">list_get_last</a> (List *list)</td></tr>
<tr class="memdesc:a6168acee09844533c26cf2889a8dc361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last element from the specified list.  <a href="#a6168acee09844533c26cf2889a8dc361">More...</a><br /></td></tr>
<tr class="separator:a6168acee09844533c26cf2889a8dc361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cf146b292c5ef48064d3ca3c677426"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a39cf146b292c5ef48064d3ca3c677426">list_get</a> (List *list, size_t index)</td></tr>
<tr class="memdesc:a39cf146b292c5ef48064d3ca3c677426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list element from the specified index.  <a href="#a39cf146b292c5ef48064d3ca3c677426">More...</a><br /></td></tr>
<tr class="separator:a39cf146b292c5ef48064d3ca3c677426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37fa04e467b37f4e6ee3edfae8207ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#ae37fa04e467b37f4e6ee3edfae8207ba">list_reverse</a> (List *list)</td></tr>
<tr class="memdesc:ae37fa04e467b37f4e6ee3edfae8207ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of element in the specified list.  <a href="#ae37fa04e467b37f4e6ee3edfae8207ba">More...</a><br /></td></tr>
<tr class="separator:ae37fa04e467b37f4e6ee3edfae8207ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265755769d0bd6246776de9e0411490e"><td class="memItemLeft" align="right" valign="top">List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a265755769d0bd6246776de9e0411490e">list_sublist</a> (List *list, size_t b, size_t e)</td></tr>
<tr class="memdesc:a265755769d0bd6246776de9e0411490e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sublist of the specified list.  <a href="#a265755769d0bd6246776de9e0411490e">More...</a><br /></td></tr>
<tr class="separator:a265755769d0bd6246776de9e0411490e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ac9e12d2987c4d81aacf432a32ffc5"><td class="memItemLeft" align="right" valign="top">List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#ae5ac9e12d2987c4d81aacf432a32ffc5">list_copy_shallow</a> (List *list)</td></tr>
<tr class="memdesc:ae5ac9e12d2987c4d81aacf432a32ffc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shallow copy of the specified list.  <a href="#ae5ac9e12d2987c4d81aacf432a32ffc5">More...</a><br /></td></tr>
<tr class="separator:ae5ac9e12d2987c4d81aacf432a32ffc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f3f67d3142434843562576de7ca8b6"><td class="memItemLeft" align="right" valign="top">List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#ad2f3f67d3142434843562576de7ca8b6">list_copy_deep</a> (List *list, void *(*cp)(void *e1))</td></tr>
<tr class="memdesc:ad2f3f67d3142434843562576de7ca8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a deep copy of the specified list.  <a href="#ad2f3f67d3142434843562576de7ca8b6">More...</a><br /></td></tr>
<tr class="separator:ad2f3f67d3142434843562576de7ca8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e7461f012987e2a478f6b1128938f8"><td class="memItemLeft" align="right" valign="top">void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a75e7461f012987e2a478f6b1128938f8">list_to_array</a> (List *list)</td></tr>
<tr class="memdesc:a75e7461f012987e2a478f6b1128938f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array representation of the specified list.  <a href="#a75e7461f012987e2a478f6b1128938f8">More...</a><br /></td></tr>
<tr class="separator:a75e7461f012987e2a478f6b1128938f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10137a70b47b20c65f51954e7e564de5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a10137a70b47b20c65f51954e7e564de5">list_contains</a> (List *list, void *element)</td></tr>
<tr class="memdesc:a10137a70b47b20c65f51954e7e564de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an integer representing the number of occurrences of the specified element within the list.  <a href="#a10137a70b47b20c65f51954e7e564de5">More...</a><br /></td></tr>
<tr class="separator:a10137a70b47b20c65f51954e7e564de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c34cbf27679a7d50a845e7d32be6a83"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a3c34cbf27679a7d50a845e7d32be6a83">list_index_of</a> (List *list, void *element)</td></tr>
<tr class="memdesc:a3c34cbf27679a7d50a845e7d32be6a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the specified element, or <code>NO_SUCH_INDEX</code> if the element is not found.  <a href="#a3c34cbf27679a7d50a845e7d32be6a83">More...</a><br /></td></tr>
<tr class="separator:a3c34cbf27679a7d50a845e7d32be6a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c72380fea0a284ba9d01d875b6a7c0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a17c72380fea0a284ba9d01d875b6a7c0">list_size</a> (List *list)</td></tr>
<tr class="memdesc:a17c72380fea0a284ba9d01d875b6a7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the specified list.  <a href="#a17c72380fea0a284ba9d01d875b6a7c0">More...</a><br /></td></tr>
<tr class="separator:a17c72380fea0a284ba9d01d875b6a7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f4a8c6da69000e247b860d7b04f628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a24f4a8c6da69000e247b860d7b04f628">list_sort</a> (List *list, int(*cmp)(void const *e1, void const *e2))</td></tr>
<tr class="memdesc:a24f4a8c6da69000e247b860d7b04f628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the specified list.  <a href="#a24f4a8c6da69000e247b860d7b04f628">More...</a><br /></td></tr>
<tr class="separator:a24f4a8c6da69000e247b860d7b04f628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2758ee3198bc274b03fc5007ab409bc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a2758ee3198bc274b03fc5007ab409bc6">list_sort_in_place</a> (List *list, int(*cmp)(void const *e1, void const *e2))</td></tr>
<tr class="memdesc:a2758ee3198bc274b03fc5007ab409bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the specified list in place in a stable way.  <a href="#a2758ee3198bc274b03fc5007ab409bc6">More...</a><br /></td></tr>
<tr class="separator:a2758ee3198bc274b03fc5007ab409bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324d245b32096c134f1898823fa44e40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a324d245b32096c134f1898823fa44e40">list_foreach</a> (List *list, void(*op)(void *e))</td></tr>
<tr class="memdesc:a324d245b32096c134f1898823fa44e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 'foreach loop' function that invokes the specified function on each element in the list.  <a href="#a324d245b32096c134f1898823fa44e40">More...</a><br /></td></tr>
<tr class="separator:a324d245b32096c134f1898823fa44e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4b6487df9b1ac58d87b4d9f73c5e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a9e4b6487df9b1ac58d87b4d9f73c5e1b">list_iter_init</a> (<a class="el" href="structListIter.html">ListIter</a> *iter, List *list)</td></tr>
<tr class="separator:a9e4b6487df9b1ac58d87b4d9f73c5e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779c66853e37a11568d54c33de9db37d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a779c66853e37a11568d54c33de9db37d">list_iter_remove</a> (<a class="el" href="structListIter.html">ListIter</a> *iter)</td></tr>
<tr class="memdesc:a779c66853e37a11568d54c33de9db37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last returned list element by the specified iterator.  <a href="#a779c66853e37a11568d54c33de9db37d">More...</a><br /></td></tr>
<tr class="separator:a779c66853e37a11568d54c33de9db37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea257379ffcc19f341d1f8f8b1613345"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#aea257379ffcc19f341d1f8f8b1613345">list_iter_add</a> (<a class="el" href="structListIter.html">ListIter</a> *iter, void *element)</td></tr>
<tr class="memdesc:aea257379ffcc19f341d1f8f8b1613345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the list.  <a href="#aea257379ffcc19f341d1f8f8b1613345">More...</a><br /></td></tr>
<tr class="separator:aea257379ffcc19f341d1f8f8b1613345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839f162f4862686b26699a83cf75a80b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a839f162f4862686b26699a83cf75a80b">list_iter_replace</a> (<a class="el" href="structListIter.html">ListIter</a> *iter, void *element)</td></tr>
<tr class="memdesc:a839f162f4862686b26699a83cf75a80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces and returns the most recently returned element by this iterator with the new element.  <a href="#a839f162f4862686b26699a83cf75a80b">More...</a><br /></td></tr>
<tr class="separator:a839f162f4862686b26699a83cf75a80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8554a74ce47c26f26ce61ef65c951c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#ae8554a74ce47c26f26ce61ef65c951c1">list_iter_has_next</a> (<a class="el" href="structListIter.html">ListIter</a> *iter)</td></tr>
<tr class="memdesc:ae8554a74ce47c26f26ce61ef65c951c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether or not there are more elements to be iterated over.  <a href="#ae8554a74ce47c26f26ce61ef65c951c1">More...</a><br /></td></tr>
<tr class="separator:ae8554a74ce47c26f26ce61ef65c951c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe80c1ae5ba2187146063c42efe0457"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#adfe80c1ae5ba2187146063c42efe0457">list_iter_index</a> (<a class="el" href="structListIter.html">ListIter</a> *iter)</td></tr>
<tr class="memdesc:adfe80c1ae5ba2187146063c42efe0457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previously returned element.  <a href="#adfe80c1ae5ba2187146063c42efe0457">More...</a><br /></td></tr>
<tr class="separator:adfe80c1ae5ba2187146063c42efe0457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42ed4a47ccd391b4fea886c35d2f771"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#af42ed4a47ccd391b4fea886c35d2f771">list_iter_next</a> (<a class="el" href="structListIter.html">ListIter</a> *iter)</td></tr>
<tr class="memdesc:af42ed4a47ccd391b4fea886c35d2f771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next element in the sequence and advances the iterator.  <a href="#af42ed4a47ccd391b4fea886c35d2f771">More...</a><br /></td></tr>
<tr class="separator:af42ed4a47ccd391b4fea886c35d2f771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7450ac09eb7ba48b287319d2907860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#aef7450ac09eb7ba48b287319d2907860">list_diter_init</a> (<a class="el" href="structListIter.html">ListIter</a> *iter, List *list)</td></tr>
<tr class="memdesc:aef7450ac09eb7ba48b287319d2907860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new descending iterator.  <a href="#aef7450ac09eb7ba48b287319d2907860">More...</a><br /></td></tr>
<tr class="separator:aef7450ac09eb7ba48b287319d2907860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6717cb6d1daff1ec48cd212805f6bcd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a6717cb6d1daff1ec48cd212805f6bcd7">list_diter_add</a> (<a class="el" href="structListIter.html">ListIter</a> *iter, void *element)</td></tr>
<tr class="memdesc:a6717cb6d1daff1ec48cd212805f6bcd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the list.  <a href="#a6717cb6d1daff1ec48cd212805f6bcd7">More...</a><br /></td></tr>
<tr class="separator:a6717cb6d1daff1ec48cd212805f6bcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062e7c33229ddf86a96f965482576a57"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a062e7c33229ddf86a96f965482576a57">list_diter_remove</a> (<a class="el" href="structListIter.html">ListIter</a> *iter)</td></tr>
<tr class="memdesc:a062e7c33229ddf86a96f965482576a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last returned list element by the specified iterator.  <a href="#a062e7c33229ddf86a96f965482576a57">More...</a><br /></td></tr>
<tr class="separator:a062e7c33229ddf86a96f965482576a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe5e99a194071d8788d5c5db8787e3c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#adbe5e99a194071d8788d5c5db8787e3c">list_diter_replace</a> (<a class="el" href="structListIter.html">ListIter</a> *iter, void *element)</td></tr>
<tr class="memdesc:adbe5e99a194071d8788d5c5db8787e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces and returns the most recently returned element by this iterator with the new element.  <a href="#adbe5e99a194071d8788d5c5db8787e3c">More...</a><br /></td></tr>
<tr class="separator:adbe5e99a194071d8788d5c5db8787e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd361c263f2eb77df51a7094c898fd6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a0cd361c263f2eb77df51a7094c898fd6">list_diter_index</a> (<a class="el" href="structListIter.html">ListIter</a> *iter)</td></tr>
<tr class="memdesc:a0cd361c263f2eb77df51a7094c898fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last returned element by <code><a class="el" href="list_8c.html#a7deb1791ef65f3fd2f285a91180e9145" title="Returns the next element in the sequence and advances the iterator. ">list_diter_next()</a> </code>.  <a href="#a0cd361c263f2eb77df51a7094c898fd6">More...</a><br /></td></tr>
<tr class="separator:a0cd361c263f2eb77df51a7094c898fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067ffe938c78db7660645843af8d6d55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a067ffe938c78db7660645843af8d6d55">list_diter_has_next</a> (<a class="el" href="structListIter.html">ListIter</a> *iter)</td></tr>
<tr class="memdesc:a067ffe938c78db7660645843af8d6d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether or not there are more element to be iterated over.  <a href="#a067ffe938c78db7660645843af8d6d55">More...</a><br /></td></tr>
<tr class="separator:a067ffe938c78db7660645843af8d6d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7deb1791ef65f3fd2f285a91180e9145"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8c.html#a7deb1791ef65f3fd2f285a91180e9145">list_diter_next</a> (<a class="el" href="structListIter.html">ListIter</a> *iter)</td></tr>
<tr class="memdesc:a7deb1791ef65f3fd2f285a91180e9145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next element in the sequence and advances the iterator.  <a href="#a7deb1791ef65f3fd2f285a91180e9145">More...</a><br /></td></tr>
<tr class="separator:a7deb1791ef65f3fd2f285a91180e9145"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac376012b2b46fc6a7028be689651bbdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_add </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the list. </p>
<p>The element is appended to the list making it the last element in the list. This function returns false if the memory allocation for the new element fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the element was succesfuly added to the list. </dd></dl>

</div>
</div>
<a class="anchor" id="a62b18d4d0dfd9be1953e3ccfa55eb5bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_add_all </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all elements from the second list to the first. </p>
<p>The elements from the second list are added after the last element of the first list. This function returns false if no elements were added to the first list. This could be the case if either the second list is empty or if the memory allocation for the elements that are being added fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list1</td><td>the list to which the elements are being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list2</td><td>the list from which the elements are being taken.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ac348bfce6082d5d4edcd1d53a5991589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_add_all_at </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all elements from the second list to the first at the specified position by shifting all subsequent elements by the size of the second list. </p>
<p>The index range at which the elements can be added ranges from 0 to max_index + 1. This function returns false if no elements were added to the first list. This could be the case if either the second list is empty or if the memory allocation for the elements being added fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list1</td><td>the list to which the elements are being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list2</td><td>the list from which the elements are being taken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>position in the first list at which the element should be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="afff0c7f6b50c7521cad56d838ba98e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_add_at </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the specified location in the list and shifts all subsequent elements by one. </p>
<p>This operation cannot be performed on an empty list. The index at which the new element is being added must be within the bounds of the list. This function returns false if either the index is out of bounds, or if the memory allocation for the new element fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list to which this element is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the position in the list at which the new element is being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the element was successfully added to the list </dd></dl>

</div>
</div>
<a class="anchor" id="ab7917a459179294d7031b8b4caf3f3d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_add_first </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepends a new element to the list (adds a new "head") making it the first element of the list. </p>
<p>This function returns false if the memory allocation for the new element fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being prepended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the element was successfuly added to the list </dd></dl>

</div>
</div>
<a class="anchor" id="a1d717433bcd6de26b57146a90c8f2547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_add_last </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a new element to the list (adds an new "tail") making it the last element of the list. </p>
<p>This function returns false if the memory allocation for the new element fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being appended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the element was successfuly added to the list </dd></dl>

</div>
</div>
<a class="anchor" id="a83f3aebf1e7382ad294ce807cf798b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_conf_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListConf.html">ListConf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the fields of the <a class="el" href="structListConf.html">ListConf</a> struct to default values. </p>
<p>[in] conf the configuration struct that is being initialized </p>

</div>
</div>
<a class="anchor" id="a10137a70b47b20c65f51954e7e564de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t list_contains </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an integer representing the number of occurrences of the specified element within the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list on which the search is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being looked for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of found matches </dd></dl>

</div>
</div>
<a class="anchor" id="ad2f3f67d3142434843562576de7ca8b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">List* list_copy_deep </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *e1)&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a deep copy of the specified list. </p>
<p>This functions copies the structure of the list along with all the data it holds. The element copying is done through the specified copy function that should return a pointer to the copy of the element passed to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>the copy function that should return a pointer to the copy of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deep copy of the list </dd></dl>

</div>
</div>
<a class="anchor" id="ae5ac9e12d2987c4d81aacf432a32ffc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">List* list_copy_shallow </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a shallow copy of the specified list. </p>
<p>A shallow copy is a copy of the list structure. This operation does not copy the actual data that this list holds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shallow copy of the list </dd></dl>

</div>
</div>
<a class="anchor" id="a087e11bba621f27c4cfbb437046d076a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_destroy </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the list structure, but leaves the data that is holds intact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>a list to destroy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="aba20a463ce16f97484b02caadf0f006e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_destroy_free </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the list structure along with all the data it holds. </p>
<p>This function returns true if the operation was successful, or false if the list was already empty.</p>
<dl class="section note"><dt>Note</dt><dd>This function should not be called on a list that has some of it's elements allocated on the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>- a list to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a6717cb6d1daff1ec48cd212805f6bcd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_diter_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the list. </p>
<p>The element is added before the element that would be returned by the next call to <code><a class="el" href="list_8c.html#a7deb1791ef65f3fd2f285a91180e9145" title="Returns the next element in the sequence and advances the iterator. ">list_diter_next()</a></code> and after the last returned element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element being added to the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a067ffe938c78db7660645843af8d6d55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_diter_has_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether or not there are more element to be iterated over. </p>
<p>This function returns true if the next element in the sequence is available, or false if the end of the list has been reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is at least one more element in the sequence or false if the end of the list has been reached. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cd361c263f2eb77df51a7094c898fd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t list_diter_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the last returned element by <code><a class="el" href="list_8c.html#a7deb1791ef65f3fd2f285a91180e9145" title="Returns the next element in the sequence and advances the iterator. ">list_diter_next()</a> </code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the last returned element </dd></dl>

</div>
</div>
<a class="anchor" id="aef7450ac09eb7ba48b287319d2907860"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_diter_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new descending iterator. </p>
<p>A descending iterator or a reverse iterator, is an iterator that traverses the list from tail to head. In case the memory allocation for the new iterator fails, NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list on which this iterator will operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new descending iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a7deb1791ef65f3fd2f285a91180e9145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_diter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next element in the sequence and advances the iterator. </p>
<dl class="section note"><dt>Note</dt><dd>Before this function is called, one should check whether the next element in the sequence exists by calling <code><a class="el" href="list_8c.html#a067ffe938c78db7660645843af8d6d55" title="Checks whether or not there are more element to be iterated over. ">list_diter_has_next()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next element in the sequence </dd></dl>

</div>
</div>
<a class="anchor" id="a062e7c33229ddf86a96f965482576a57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_diter_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last returned list element by the specified iterator. </p>
<p>Since this function removes the last returned element, it should only be called after a call to <code><a class="el" href="list_8c.html#a7deb1791ef65f3fd2f285a91180e9145" title="Returns the next element in the sequence and advances the iterator. ">list_diter_next()</a></code>. Only the first call to this function removes the element. Any subsequent calls will have no effect until the <code><a class="el" href="list_8c.html#a7deb1791ef65f3fd2f285a91180e9145" title="Returns the next element in the sequence and advances the iterator. ">list_diter_next()</a></code> is called again.</p>
<dl class="section note"><dt>Note</dt><dd>This function should only ever be called after a call to <code><a class="el" href="list_8c.html#a7deb1791ef65f3fd2f285a91180e9145" title="Returns the next element in the sequence and advances the iterator. ">list_diter_next()</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element, or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="adbe5e99a194071d8788d5c5db8787e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_diter_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces and returns the most recently returned element by this iterator with the new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the replacement element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the replaced element </dd></dl>

</div>
</div>
<a class="anchor" id="a324d245b32096c134f1898823fa44e40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_foreach </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *e)&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 'foreach loop' function that invokes the specified function on each element in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>the operation function that is to be invoked on each list element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39cf146b292c5ef48064d3ca3c677426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_get </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list element from the specified index. </p>
<p>In case the index is out of bounds, this function returns NULL instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list from which the element is being returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of a list element being returned. The index must be within the bound of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list element at the specified index. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8e74fc7780605306269a5c71ab674b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_get_first </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first element from the specified list, or NULL if the list is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list whose first element is being returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first element of the list, or NULL in case the list is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a6168acee09844533c26cf2889a8dc361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_get_last </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last element from the specified list. </p>
<p>or NULL if the list is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list whose last element is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last element of the list, or NULL in case the list is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c34cbf27679a7d50a845e7d32be6a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t list_index_of </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the specified element, or <code>NO_SUCH_INDEX</code> if the element is not found. </p>
<p>The returned index is the index of the first occurrence of the element starting from the beginning of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list on which this operation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element whose index is being looked up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the specified element or <code>NO_SUCH_INDEX</code> if the element is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="aea257379ffcc19f341d1f8f8b1613345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_iter_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the list. </p>
<p>The element is added before the element that would be returned by the next call to <code><a class="el" href="list_8c.html#af42ed4a47ccd391b4fea886c35d2f771" title="Returns the next element in the sequence and advances the iterator. ">list_iter_next()</a></code> and after the last returned element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element being added to the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="ae8554a74ce47c26f26ce61ef65c951c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_iter_has_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether or not there are more elements to be iterated over. </p>
<p>Returns true if the next element is available, or false if the end of the list has been reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is at least one more element in the sequence or false if the end of the list has been reached. </dd></dl>

</div>
</div>
<a class="anchor" id="adfe80c1ae5ba2187146063c42efe0457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t list_iter_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the previously returned element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the previously returned element. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e4b6487df9b1ac58d87b4d9f73c5e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_iter_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af42ed4a47ccd391b4fea886c35d2f771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_iter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next element in the sequence and advances the iterator. </p>
<dl class="section note"><dt>Note</dt><dd>Before this function is called, one should check whether the next element in the sequence exists by calling <code><a class="el" href="list_8c.html#ae8554a74ce47c26f26ce61ef65c951c1" title="Checks whether or not there are more elements to be iterated over. ">list_iter_has_next()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>iterator on which this operation is being performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next element in the sequence </dd></dl>

</div>
</div>
<a class="anchor" id="a779c66853e37a11568d54c33de9db37d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_iter_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last returned list element by the specified iterator. </p>
<p>Since this function removes the last returned element, it should only be called after a call to <code><a class="el" href="list_8c.html#af42ed4a47ccd391b4fea886c35d2f771" title="Returns the next element in the sequence and advances the iterator. ">list_iter_next()</a></code>. Only the first call to this function removes the element. Any subsequent calls will have no effect until the <code><a class="el" href="list_8c.html#af42ed4a47ccd391b4fea886c35d2f771" title="Returns the next element in the sequence and advances the iterator. ">list_iter_next()</a></code> is called again.</p>
<dl class="section note"><dt>Note</dt><dd>This function should only ever be called after a call to <code> <a class="el" href="list_8c.html#af42ed4a47ccd391b4fea886c35d2f771" title="Returns the next element in the sequence and advances the iterator. ">list_iter_next()</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element, or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a839f162f4862686b26699a83cf75a80b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_iter_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListIter.html">ListIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces and returns the most recently returned element by this iterator with the new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the replacement element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the replaced element </dd></dl>

</div>
</div>
<a class="anchor" id="a4014f5a2de9e5167f343fb75092adae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">List* list_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new empty list, or NULL if the memory allocation fails. </p>
<dl class="section return"><dt>Returns</dt><dd>a new list if the allocation was successful, or NULL if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d0e7a284d7d3a024e88cec289ceeb7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">List* list_new_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structListConf.html">ListConf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new empty list based on the specified <a class="el" href="structListConf.html">ListConf</a> struct. </p>
<p>The List is allocated using the allocators specified in the <a class="el" href="structListConf.html">ListConf</a> struct. The allocation may fail if the undelying allocator fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>the configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new list if the allocation was successful, or NULL if not. </dd></dl>

</div>
</div>
<a class="anchor" id="aed6401a554f3c550f04d83aa4c3db946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_remove </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the first occurrence of the element from the specified list. </p>
<p>If the element is not a part of the list, NULL is returned. NULL may also be returned if the removed element was NULL. Calling <code> <a class="el" href="list_8c.html#a10137a70b47b20c65f51954e7e564de5" title="Returns an integer representing the number of occurrences of the specified element within the list...">list_contains()</a></code> before this function can resolve the ambiguity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>a list from which the element is being removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>element being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element </dd></dl>

</div>
</div>
<a class="anchor" id="a580ac58766c66691c082405ad769690c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_remove_all </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the specified list. </p>
<p>This function returns true if at least one element was removed, or false if the list was already empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which all elements are being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful and at least one element was removed, or false if the list was already empty </dd></dl>

</div>
</div>
<a class="anchor" id="a29fbfc5b25677a607742b4b824c7ee3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_remove_all_free </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and frees all the elements from the specified list. </p>
<p>This function returns true if at least one element was removed and freed, or false if the list was already empty.</p>
<dl class="section note"><dt>Note</dt><dd>This function should not be called on a list that has some of it's elements allocated on the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which all the elements are being removed and freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful and at least one element was removed or false if the list is already empty </dd></dl>

</div>
</div>
<a class="anchor" id="aae3ae97b756103f185a98f920b680759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_remove_at </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the element at the specified index. </p>
<p>The index must be within the bounds of the list. In case the index is out of bounds this function returns NULL. NULL may also be returned if the element at the specified index is actually NULL. Calling <code><a class="el" href="list_8c.html#a10137a70b47b20c65f51954e7e564de5" title="Returns an integer representing the number of occurrences of the specified element within the list...">list_contains()</a></code> before this function can resolve this ambiguity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which the element is being removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of the element is being removed. Must be be within the index range of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element, or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="aefe34a6b6762d37e9b1c1246a97e387b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_remove_first </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the first (head) element of the list. </p>
<p>If the list is empty, NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which the first element is being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element </dd></dl>

</div>
</div>
<a class="anchor" id="a6e8cde03c75d840976c92fc2fbf36c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_remove_last </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the first (tail) element of the list. </p>
<p>If the list is empty, NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which the last element is being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a39f3e736f60d9adf26084658bb32ebe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_replace_at </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces an element at the specified location and returns the old element. </p>
<p>The specified index must be within the bounds of the list. This function returns false if the specified index is out of range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list on which this operation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the replacement element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of the element being replaced</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the replaced element </dd></dl>

</div>
</div>
<a class="anchor" id="ae37fa04e467b37f4e6ee3edfae8207ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_reverse </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the order of element in the specified list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list that is being reversed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17c72380fea0a284ba9d01d875b6a7c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t list_size </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the specified list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>whose size is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the elements contained in the specified list </dd></dl>

</div>
</div>
<a class="anchor" id="a24f4a8c6da69000e247b860d7b04f628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_sort </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void const *e1, void const *e2)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the specified list. </p>
<p>This function makes no guaranties that the sort will be performed in place or in a stable way.</p>
<dl class="section note"><dt>Note</dt><dd>Pointers passed to the comparator function will be pointers to the list elements that are of type (void*) ie. void**. So an extra step of dereferencing will be required before the data can be used for comparison: eg. <code>my_type e = *(*((my_type**) ptr));</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>the comparator function that must be of type <code> int cmp(const void e1*, const void e2*)</code> that returns &lt; 0 if the first element goes before the second, 0 if the elements are equal and &gt; 0 if the second goes before the first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2758ee3198bc274b03fc5007ab409bc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_sort_in_place </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void const *e1, void const *e2)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the specified list in place in a stable way. </p>
<dl class="section note"><dt>Note</dt><dd>Pointers passed to the comparator function will be pointers to the list elements that are of type (void*) ie. void**. So an extra step of dereferencing will be required before the data can be used for comparison: eg. <code>my_type e = *(*((my_type**) ptr));</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>the comparator function that must be of type <code> int cmp(const void e1*, const void e2*)</code> that returns &lt; 0 if the first element goes before the second, 0 if the elements are equal and &gt; 0 if the second goes before the first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5f879e3662fa0d03e8f89a178b5c3e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_splice </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splices the two doubly linked lists together by appending the second list to the first. </p>
<p>This function moves all the elements from the second list into the first list, leaving the second list empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list1</td><td>The consumer list to which the elements are moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list2</td><td>The producer list from which the elements are moved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="ab721694878df9d5c20de4267eb623e40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool list_splice_at </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splices the two lists together at the specified index of the first list. </p>
<p>This function moves all the element from the second list into the frist list at the position specified by the <code>index</code> parameter. After this opertaion the second list will be left empty. This function returns false if the second list is already empty or if the specified index is out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list1</td><td>the consumer list to which the elements are moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list2</td><td>the producer list from which the elements are moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the first list after which the elements from the second list should be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if at least one element was moved from the second list </dd></dl>

</div>
</div>
<a class="anchor" id="a265755769d0bd6246776de9e0411490e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">List* list_sublist </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sublist of the specified list. </p>
<p>The returned sublist contains all the elements from the list that are contained between the two indices including the elements at the indices. For example if a list contains 5 elements [5, 6, 7, 8, 9], a sublist from index 1 to 3 will will be a new list of length 3, containing [6, 7, 8]. The returned sublist is only a copy of the original lists structure, meaning the data it points to is not copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list from which the sublist is taken </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The beginning index, ie., the first element to be included. Must be a positive integer and may not exceed the list size or the end index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The ending index, ie., the last element to be included. Must be a positive integer no greater that the list size and no smaller that the beginning index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new sublist or NULL if any of the indices are out of list bounds </dd></dl>

</div>
</div>
<a class="anchor" id="a75e7461f012987e2a478f6b1128938f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void** list_to_array </td>
          <td>(</td>
          <td class="paramtype">List *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array representation of the specified list. </p>
<p>None of the elements are copied into the array and thus any modification of the elements within the array will affect the list elements as well. The size of the returned array is the same as the size of the list from which this array was constructed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>the list on which this operation is being performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array representation of the specified list </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 11 2015 14:07:07 for Collections-C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
