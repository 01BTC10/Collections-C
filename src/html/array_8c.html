<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Collections-C: array.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Collections-C
   </div>
   <div id="projectbrief">A library of generic container types.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">array.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="array_8h_source.html">array.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarray__s.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic array that expands automatically as elements are added.  <a href="structarray__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2af6bf843475565a9681f9449a3d5cc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a2af6bf843475565a9681f9449a3d5cc2">DEFAULT_CAPACITY</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a2af6bf843475565a9681f9449a3d5cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36982708a1a76345461d2ecebb3e92e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ac36982708a1a76345461d2ecebb3e92e">DEFAULT_EXPANSION_FACTOR</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac36982708a1a76345461d2ecebb3e92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adbcb929cd348c41fbef79ce5b448ba40"><td class="memItemLeft" align="right" valign="top">Array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#adbcb929cd348c41fbef79ce5b448ba40">array_new</a> ()</td></tr>
<tr class="memdesc:adbcb929cd348c41fbef79ce5b448ba40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new empty array, or NULL if the allocation fails.  <a href="#adbcb929cd348c41fbef79ce5b448ba40">More...</a><br /></td></tr>
<tr class="separator:adbcb929cd348c41fbef79ce5b448ba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea17531e99fa622a3593d2480afb25c"><td class="memItemLeft" align="right" valign="top">Array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#aaea17531e99fa622a3593d2480afb25c">array_new_conf</a> (<a class="el" href="structArrayConf.html">ArrayConf</a> *conf)</td></tr>
<tr class="memdesc:aaea17531e99fa622a3593d2480afb25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new empty array based on the specified <a class="el" href="structArrayConf.html" title="Array configuration object. ">ArrayConf</a> struct.  <a href="#aaea17531e99fa622a3593d2480afb25c">More...</a><br /></td></tr>
<tr class="separator:aaea17531e99fa622a3593d2480afb25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254e01e0d7d4b92224b8edac9055723c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a254e01e0d7d4b92224b8edac9055723c">array_conf_init</a> (<a class="el" href="structArrayConf.html">ArrayConf</a> *conf)</td></tr>
<tr class="memdesc:a254e01e0d7d4b92224b8edac9055723c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the fields of the <a class="el" href="structArrayConf.html" title="Array configuration object. ">ArrayConf</a> struct to default values.  <a href="#a254e01e0d7d4b92224b8edac9055723c">More...</a><br /></td></tr>
<tr class="separator:a254e01e0d7d4b92224b8edac9055723c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1653efc8d9745e1342febc0e3e0af962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a1653efc8d9745e1342febc0e3e0af962">array_destroy</a> (Array *ar)</td></tr>
<tr class="memdesc:a1653efc8d9745e1342febc0e3e0af962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the array structure, but leaves the data it used to hold, intact.  <a href="#a1653efc8d9745e1342febc0e3e0af962">More...</a><br /></td></tr>
<tr class="separator:a1653efc8d9745e1342febc0e3e0af962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c28f9dbc652a80c0f6343c2bb0be556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a8c28f9dbc652a80c0f6343c2bb0be556">array_destroy_free</a> (Array *ar)</td></tr>
<tr class="memdesc:a8c28f9dbc652a80c0f6343c2bb0be556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the Array structure along with all the data it holds.  <a href="#a8c28f9dbc652a80c0f6343c2bb0be556">More...</a><br /></td></tr>
<tr class="separator:a8c28f9dbc652a80c0f6343c2bb0be556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f538d39060bcbb95a7e15d1e9a84656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a0f538d39060bcbb95a7e15d1e9a84656">array_add</a> (Array *ar, void *element)</td></tr>
<tr class="memdesc:a0f538d39060bcbb95a7e15d1e9a84656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the Array.  <a href="#a0f538d39060bcbb95a7e15d1e9a84656">More...</a><br /></td></tr>
<tr class="separator:a0f538d39060bcbb95a7e15d1e9a84656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb3267f91793cc3a56fe47174bbe5d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a0eb3267f91793cc3a56fe47174bbe5d2">array_add_at</a> (Array *ar, void *element, size_t index)</td></tr>
<tr class="memdesc:a0eb3267f91793cc3a56fe47174bbe5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the array at a specified position by shifting all subsequent elemnts by one.  <a href="#a0eb3267f91793cc3a56fe47174bbe5d2">More...</a><br /></td></tr>
<tr class="separator:a0eb3267f91793cc3a56fe47174bbe5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819f1da2f6e026dcd71b12aa78a5a98b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a819f1da2f6e026dcd71b12aa78a5a98b">array_replace_at</a> (Array *ar, void *element, size_t index)</td></tr>
<tr class="memdesc:a819f1da2f6e026dcd71b12aa78a5a98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a array element at the specified index and returns the replaced element.  <a href="#a819f1da2f6e026dcd71b12aa78a5a98b">More...</a><br /></td></tr>
<tr class="separator:a819f1da2f6e026dcd71b12aa78a5a98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54622a0cc3ce7e2b02bc4a2bff2e8dc9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a54622a0cc3ce7e2b02bc4a2bff2e8dc9">array_remove</a> (Array *ar, void *element)</td></tr>
<tr class="memdesc:a54622a0cc3ce7e2b02bc4a2bff2e8dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the specified element from the array if such element exists.  <a href="#a54622a0cc3ce7e2b02bc4a2bff2e8dc9">More...</a><br /></td></tr>
<tr class="separator:a54622a0cc3ce7e2b02bc4a2bff2e8dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43c253f048caaa4bb81d579ca99e31b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ad43c253f048caaa4bb81d579ca99e31b">array_remove_at</a> (Array *ar, size_t index)</td></tr>
<tr class="memdesc:ad43c253f048caaa4bb81d579ca99e31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns a array element from the specified index.  <a href="#ad43c253f048caaa4bb81d579ca99e31b">More...</a><br /></td></tr>
<tr class="separator:ad43c253f048caaa4bb81d579ca99e31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277be752070ce86b6f410e0da862648c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a277be752070ce86b6f410e0da862648c">array_remove_last</a> (Array *ar)</td></tr>
<tr class="memdesc:a277be752070ce86b6f410e0da862648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns a array element from the end of the array.  <a href="#a277be752070ce86b6f410e0da862648c">More...</a><br /></td></tr>
<tr class="separator:a277be752070ce86b6f410e0da862648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b26295477a6717a4708776952db5f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ab2b26295477a6717a4708776952db5f6">array_remove_all</a> (Array *ar)</td></tr>
<tr class="memdesc:ab2b26295477a6717a4708776952db5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the specified array.  <a href="#ab2b26295477a6717a4708776952db5f6">More...</a><br /></td></tr>
<tr class="separator:ab2b26295477a6717a4708776952db5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca98ad1af5fdce9d540011cf4751b3b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#aca98ad1af5fdce9d540011cf4751b3b3">array_remove_all_free</a> (Array *ar)</td></tr>
<tr class="memdesc:aca98ad1af5fdce9d540011cf4751b3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and frees all elements from the specified array.  <a href="#aca98ad1af5fdce9d540011cf4751b3b3">More...</a><br /></td></tr>
<tr class="separator:aca98ad1af5fdce9d540011cf4751b3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c6558fff849bf2d6f940c9fb6d8abe"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a15c6558fff849bf2d6f940c9fb6d8abe">array_get</a> (Array *ar, size_t index)</td></tr>
<tr class="memdesc:a15c6558fff849bf2d6f940c9fb6d8abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a array element from the specified index.  <a href="#a15c6558fff849bf2d6f940c9fb6d8abe">More...</a><br /></td></tr>
<tr class="separator:a15c6558fff849bf2d6f940c9fb6d8abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2e438d18ffe2a8d593016cd409e001"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ace2e438d18ffe2a8d593016cd409e001">array_get_last</a> (Array *ar)</td></tr>
<tr class="memdesc:ace2e438d18ffe2a8d593016cd409e001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last element of the array ie.  <a href="#ace2e438d18ffe2a8d593016cd409e001">More...</a><br /></td></tr>
<tr class="separator:ace2e438d18ffe2a8d593016cd409e001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8679f730af9d59c5aef38a4f3da6a5e2"><td class="memItemLeft" align="right" valign="top">const void *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a8679f730af9d59c5aef38a4f3da6a5e2">array_get_buffer</a> (Array *ar)</td></tr>
<tr class="memdesc:a8679f730af9d59c5aef38a4f3da6a5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying array buffer.  <a href="#a8679f730af9d59c5aef38a4f3da6a5e2">More...</a><br /></td></tr>
<tr class="separator:a8679f730af9d59c5aef38a4f3da6a5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e59e96a7b976c0fc8fcdc2e26aa6a08"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a6e59e96a7b976c0fc8fcdc2e26aa6a08">array_index_of</a> (Array *ar, void *element)</td></tr>
<tr class="memdesc:a6e59e96a7b976c0fc8fcdc2e26aa6a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first occurrence of the specified array element, or NO_SUCH_INDEX if the element could not be found.  <a href="#a6e59e96a7b976c0fc8fcdc2e26aa6a08">More...</a><br /></td></tr>
<tr class="separator:a6e59e96a7b976c0fc8fcdc2e26aa6a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af022b124faef5b1074ed55b79b0d076e"><td class="memItemLeft" align="right" valign="top">Array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#af022b124faef5b1074ed55b79b0d076e">array_subarray</a> (Array *ar, size_t b, size_t e)</td></tr>
<tr class="memdesc:af022b124faef5b1074ed55b79b0d076e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a subarray of the specified array, randing from <code>b</code> index (inclusive) to <code>e</code> index (inclusive).  <a href="#af022b124faef5b1074ed55b79b0d076e">More...</a><br /></td></tr>
<tr class="separator:af022b124faef5b1074ed55b79b0d076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8fd0c3933d3a192407876effc4a80e"><td class="memItemLeft" align="right" valign="top">Array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ace8fd0c3933d3a192407876effc4a80e">array_copy_shallow</a> (Array *ar)</td></tr>
<tr class="memdesc:ace8fd0c3933d3a192407876effc4a80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shallow copy of the specified array.  <a href="#ace8fd0c3933d3a192407876effc4a80e">More...</a><br /></td></tr>
<tr class="separator:ace8fd0c3933d3a192407876effc4a80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc66eb1b5326cb30ba91fc763977824"><td class="memItemLeft" align="right" valign="top">Array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a8fc66eb1b5326cb30ba91fc763977824">array_copy_deep</a> (Array *ar, void *(*cp)(void *))</td></tr>
<tr class="memdesc:a8fc66eb1b5326cb30ba91fc763977824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a deep copy of the specified array.  <a href="#a8fc66eb1b5326cb30ba91fc763977824">More...</a><br /></td></tr>
<tr class="separator:a8fc66eb1b5326cb30ba91fc763977824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ef0dd25e5f57ffcaa9de1c4a4dd2d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a72ef0dd25e5f57ffcaa9de1c4a4dd2d3">array_reverse</a> (Array *ar)</td></tr>
<tr class="memdesc:a72ef0dd25e5f57ffcaa9de1c4a4dd2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of elements in the specified array.  <a href="#a72ef0dd25e5f57ffcaa9de1c4a4dd2d3">More...</a><br /></td></tr>
<tr class="separator:a72ef0dd25e5f57ffcaa9de1c4a4dd2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a526de0a359cd5a6d3784ebd5afe4c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a1a526de0a359cd5a6d3784ebd5afe4c8">array_trim_capacity</a> (Array *ar)</td></tr>
<tr class="memdesc:a1a526de0a359cd5a6d3784ebd5afe4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the array's capacity, in other words, it shrinks the capacity to match the number of elements in the specified array, however the capacity will never shrink below 1.  <a href="#a1a526de0a359cd5a6d3784ebd5afe4c8">More...</a><br /></td></tr>
<tr class="separator:a1a526de0a359cd5a6d3784ebd5afe4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c462b132d8ea30c69d7d3281d27abe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a42c462b132d8ea30c69d7d3281d27abe">array_contains</a> (Array *ar, void *element)</td></tr>
<tr class="memdesc:a42c462b132d8ea30c69d7d3281d27abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of occurrences of the element within the specified array.  <a href="#a42c462b132d8ea30c69d7d3281d27abe">More...</a><br /></td></tr>
<tr class="separator:a42c462b132d8ea30c69d7d3281d27abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1642fa6d156a8ba9c9e77d9f9883bc01"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a1642fa6d156a8ba9c9e77d9f9883bc01">array_size</a> (Array *ar)</td></tr>
<tr class="memdesc:a1642fa6d156a8ba9c9e77d9f9883bc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the specified array.  <a href="#a1642fa6d156a8ba9c9e77d9f9883bc01">More...</a><br /></td></tr>
<tr class="separator:a1642fa6d156a8ba9c9e77d9f9883bc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289a7c8ea228d9658d5d37a8eb11ea57"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a289a7c8ea228d9658d5d37a8eb11ea57">array_capacity</a> (Array *ar)</td></tr>
<tr class="memdesc:a289a7c8ea228d9658d5d37a8eb11ea57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the specified array.  <a href="#a289a7c8ea228d9658d5d37a8eb11ea57">More...</a><br /></td></tr>
<tr class="separator:a289a7c8ea228d9658d5d37a8eb11ea57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da93b02bbb9e5292b2e9378f1c7260d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a0da93b02bbb9e5292b2e9378f1c7260d">array_sort</a> (Array *ar, int(*cmp)(const void *, const void *))</td></tr>
<tr class="memdesc:a0da93b02bbb9e5292b2e9378f1c7260d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the specified array.  <a href="#a0da93b02bbb9e5292b2e9378f1c7260d">More...</a><br /></td></tr>
<tr class="separator:a0da93b02bbb9e5292b2e9378f1c7260d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3df334f7398a0181356fc134918b51c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#aa3df334f7398a0181356fc134918b51c">array_foreach</a> (Array *ar, void(*op)(void *e))</td></tr>
<tr class="memdesc:aa3df334f7398a0181356fc134918b51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 'foreach loop' function that invokes the specified function on each element in the array.  <a href="#aa3df334f7398a0181356fc134918b51c">More...</a><br /></td></tr>
<tr class="separator:aa3df334f7398a0181356fc134918b51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1873de5095c2bd9c4a99b108ffd784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a7e1873de5095c2bd9c4a99b108ffd784">array_iter_init</a> (<a class="el" href="structArrayIter.html">ArrayIter</a> *iter, Array *ar)</td></tr>
<tr class="memdesc:a7e1873de5095c2bd9c4a99b108ffd784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the iterator.  <a href="#a7e1873de5095c2bd9c4a99b108ffd784">More...</a><br /></td></tr>
<tr class="separator:a7e1873de5095c2bd9c4a99b108ffd784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af029ebd32a21e9fe9349e909ac16304b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#af029ebd32a21e9fe9349e909ac16304b">array_iter_has_next</a> (<a class="el" href="structArrayIter.html">ArrayIter</a> *iter)</td></tr>
<tr class="memdesc:af029ebd32a21e9fe9349e909ac16304b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether or not the iterator has reached the end of the array.  <a href="#af029ebd32a21e9fe9349e909ac16304b">More...</a><br /></td></tr>
<tr class="separator:af029ebd32a21e9fe9349e909ac16304b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb45a79aaae2005ae51480c7b6bd495"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495">array_iter_next</a> (<a class="el" href="structArrayIter.html">ArrayIter</a> *iter)</td></tr>
<tr class="memdesc:abcb45a79aaae2005ae51480c7b6bd495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next element in the sequence and advances the iterator.  <a href="#abcb45a79aaae2005ae51480c7b6bd495">More...</a><br /></td></tr>
<tr class="separator:abcb45a79aaae2005ae51480c7b6bd495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cf02f64edf00efb83acfee90e31406"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a30cf02f64edf00efb83acfee90e31406">array_iter_remove</a> (<a class="el" href="structArrayIter.html">ArrayIter</a> *iter)</td></tr>
<tr class="memdesc:a30cf02f64edf00efb83acfee90e31406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the last returned element by <code><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495" title="Returns the next element in the sequence and advances the iterator. ">array_iter_next()</a> </code> without invalidating the iterator.  <a href="#a30cf02f64edf00efb83acfee90e31406">More...</a><br /></td></tr>
<tr class="separator:a30cf02f64edf00efb83acfee90e31406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdc6fb12d224ba2ab911fbed987c09f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#aefdc6fb12d224ba2ab911fbed987c09f">array_iter_add</a> (<a class="el" href="structArrayIter.html">ArrayIter</a> *iter, void *element)</td></tr>
<tr class="memdesc:aefdc6fb12d224ba2ab911fbed987c09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the array after the last retuned element by <code><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495" title="Returns the next element in the sequence and advances the iterator. ">array_iter_next()</a></code>, without invalidating the iterator.  <a href="#aefdc6fb12d224ba2ab911fbed987c09f">More...</a><br /></td></tr>
<tr class="separator:aefdc6fb12d224ba2ab911fbed987c09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1552117378c38f913bff434ec999b5dc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a1552117378c38f913bff434ec999b5dc">array_iter_replace</a> (<a class="el" href="structArrayIter.html">ArrayIter</a> *iter, void *element)</td></tr>
<tr class="memdesc:a1552117378c38f913bff434ec999b5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the last returned element by <code><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495" title="Returns the next element in the sequence and advances the iterator. ">array_iter_next()</a></code> with the specified replacement element.  <a href="#a1552117378c38f913bff434ec999b5dc">More...</a><br /></td></tr>
<tr class="separator:a1552117378c38f913bff434ec999b5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2177e073fc4d3436dd5f2c82f377e109"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a2177e073fc4d3436dd5f2c82f377e109">array_iter_index</a> (<a class="el" href="structArrayIter.html">ArrayIter</a> *iter)</td></tr>
<tr class="memdesc:a2177e073fc4d3436dd5f2c82f377e109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last returned element by <code><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495" title="Returns the next element in the sequence and advances the iterator. ">array_iter_next()</a> </code>.  <a href="#a2177e073fc4d3436dd5f2c82f377e109">More...</a><br /></td></tr>
<tr class="separator:a2177e073fc4d3436dd5f2c82f377e109"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a2af6bf843475565a9681f9449a3d5cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_CAPACITY&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac36982708a1a76345461d2ecebb3e92e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_EXPANSION_FACTOR&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0f538d39060bcbb95a7e15d1e9a84656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool array_add </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the Array. </p>
<p>The element is appended to the array making it the last element (the one with the highest index) of the Array. This function returns a <code>bool</code> based on whether or not the memory allocation for the new element was successful or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the Array to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element that is being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a0eb3267f91793cc3a56fe47174bbe5d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool array_add_at </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the array at a specified position by shifting all subsequent elemnts by one. </p>
<p>The specified index must be within the bounds of the array, otherwise this operation will fail and false will be returned to indicate failure. This function may also fail if the memory allocation for the new element was unsuccessful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the Array to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element that is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the position in the array at which the element is being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a289a7c8ea228d9658d5d37a8eb11ea57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t array_capacity </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the capacity of the specified array. </p>
<p>The capacity of the array is the maximum number of elements a array can hold before it has to be resized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>array whose capacity is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity of the array </dd></dl>

</div>
</div>
<a class="anchor" id="a254e01e0d7d4b92224b8edac9055723c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_conf_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structArrayConf.html">ArrayConf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the fields of the <a class="el" href="structArrayConf.html" title="Array configuration object. ">ArrayConf</a> struct to default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">conf</td><td><a class="el" href="structArrayConf.html" title="Array configuration object. ">ArrayConf</a> being initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42c462b132d8ea30c69d7d3281d27abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t array_contains </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of occurrences of the element within the specified array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array that is being searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element that is being searched for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of occurrences of the element </dd></dl>

</div>
</div>
<a class="anchor" id="a8fc66eb1b5326cb30ba91fc763977824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array* array_copy_deep </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a deep copy of the specified array. </p>
<p>A deep copy is a copy of both the array structure and the data it holds.</p>
<dl class="section note"><dt>Note</dt><dd>The new array is allocated using the original arrays allocators and also inherits the configuration of the original array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>the copy function that returns a copy of a array element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deep copy of the specified array </dd></dl>

</div>
</div>
<a class="anchor" id="ace8fd0c3933d3a192407876effc4a80e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array* array_copy_shallow </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a shallow copy of the specified array. </p>
<p>A shallow copy is a copy of the array structure, but not the elements it holds.</p>
<dl class="section note"><dt>Note</dt><dd>The new array is allocated using the original arrays allocators and also inherits the configuration of the original array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shallow copy of the specified array </dd></dl>

</div>
</div>
<a class="anchor" id="a1653efc8d9745e1342febc0e3e0af962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_destroy </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the array structure, but leaves the data it used to hold, intact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the Array that is to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c28f9dbc652a80c0f6343c2bb0be556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_destroy_free </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the Array structure along with all the data it holds. </p>
<dl class="section note"><dt>Note</dt><dd>This function should not be called on a array that has some of its elements allocated on the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array that is being destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3df334f7398a0181356fc134918b51c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_foreach </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *e)&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 'foreach loop' function that invokes the specified function on each element in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array on which this operation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>the operation function that is to be invoked on each array element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15c6558fff849bf2d6f940c9fb6d8abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* array_get </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a array element from the specified index. </p>
<p>The specified index must be within the bounds of the array, otherwise NULL is returned. NULL can also be returned if the element at the specified index is NULL. This ambiguity can be resolved by calling <code><a class="el" href="array_8c.html#a42c462b132d8ea30c69d7d3281d27abe" title="Returns the number of occurrences of the element within the specified array. ">array_contains()</a></code> before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array from which the element is being retrieved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of the array element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array element at the specified index, or NULL if the operation has failed </dd></dl>

</div>
</div>
<a class="anchor" id="a8679f730af9d59c5aef38a4f3da6a5e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* const* array_get_buffer </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the underlying array buffer. </p>
<dl class="section note"><dt>Note</dt><dd>Any direct modification of the buffer may invalidate the array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array whose underlying buffer is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ace2e438d18ffe2a8d593016cd409e001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* array_get_last </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last element of the array ie. </p>
<p>the element at the highest index, or NULL if the array is empty. Null may also be returned if the last element of the array is NULL. This ambiguity can be resolved by calling <code> <a class="el" href="array_8c.html#a1642fa6d156a8ba9c9e77d9f9883bc01" title="Returns the size of the specified array. ">array_size()</a></code> before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array whose last element is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last element of the specified array </dd></dl>

</div>
</div>
<a class="anchor" id="a6e59e96a7b976c0fc8fcdc2e26aa6a08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t array_index_of </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the first occurrence of the specified array element, or NO_SUCH_INDEX if the element could not be found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>array being searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element whose index is being looked up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the specified element, or NO_SUCH_INDEX if the element is not found </dd></dl>

</div>
</div>
<a class="anchor" id="aefdc6fb12d224ba2ab911fbed987c09f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool array_iter_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structArrayIter.html">ArrayIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the array after the last retuned element by <code><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495" title="Returns the next element in the sequence and advances the iterator. ">array_iter_next()</a></code>, without invalidating the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the element was successfully added or false if the allocation for the new element failed. </dd></dl>

</div>
</div>
<a class="anchor" id="af029ebd32a21e9fe9349e909ac16304b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool array_iter_has_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structArrayIter.html">ArrayIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether or not the iterator has reached the end of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>iterator whose position is being checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are more elements to be iterated over, or false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a2177e073fc4d3436dd5f2c82f377e109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t array_iter_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structArrayIter.html">ArrayIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the last returned element by <code><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495" title="Returns the next element in the sequence and advances the iterator. ">array_iter_next()</a> </code>. </p>
<dl class="section note"><dt>Note</dt><dd>This function should not be called before a call to <code><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495" title="Returns the next element in the sequence and advances the iterator. ">array_iter_next()</a> </code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index </dd></dl>

</div>
</div>
<a class="anchor" id="a7e1873de5095c2bd9c4a99b108ffd784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_iter_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structArrayIter.html">ArrayIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator that is being initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array to iterate over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcb45a79aaae2005ae51480c7b6bd495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* array_iter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structArrayIter.html">ArrayIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next element in the sequence and advances the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator that is being advanced</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next element in the sequence </dd></dl>

</div>
</div>
<a class="anchor" id="a30cf02f64edf00efb83acfee90e31406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* array_iter_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structArrayIter.html">ArrayIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the last returned element by <code><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495" title="Returns the next element in the sequence and advances the iterator. ">array_iter_next()</a> </code> without invalidating the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element </dd></dl>

</div>
</div>
<a class="anchor" id="a1552117378c38f913bff434ec999b5dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* array_iter_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structArrayIter.html">ArrayIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the last returned element by <code><a class="el" href="array_8c.html#abcb45a79aaae2005ae51480c7b6bd495" title="Returns the next element in the sequence and advances the iterator. ">array_iter_next()</a></code> with the specified replacement element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the replacement element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old element that was replaced by the new one </dd></dl>

</div>
</div>
<a class="anchor" id="adbcb929cd348c41fbef79ce5b448ba40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array* array_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new empty array, or NULL if the allocation fails. </p>
<dl class="section return"><dt>Returns</dt><dd>a new array if the allocation was successful, or NULL if it was not. </dd></dl>

</div>
</div>
<a class="anchor" id="aaea17531e99fa622a3593d2480afb25c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array* array_new_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structArrayConf.html">ArrayConf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new empty array based on the specified <a class="el" href="structArrayConf.html" title="Array configuration object. ">ArrayConf</a> struct. </p>
<p>The array is allocated using the allocators specified in the <a class="el" href="structArrayConf.html" title="Array configuration object. ">ArrayConf</a> struct. The allocation may fail if underlying allocator fails. It may also fail if the values of exp_factor and capacity in the <a class="el" href="structArrayConf.html" title="Array configuration object. ">ArrayConf</a> do not meet the following condition: <code>exp_factor &lt; (MAX_ELEMENTS / capacity)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>Array configuration object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new array if the allocation was successful, or NULL if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a54622a0cc3ce7e2b02bc4a2bff2e8dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* array_remove </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the specified element from the array if such element exists. </p>
<p>In case the element does not exist NULL is returned. NULL can also be returned if the specified element is NULL. In this case calling <code> <a class="el" href="array_8c.html#a42c462b132d8ea30c69d7d3281d27abe" title="Returns the number of occurrences of the element within the specified array. ">array_contains()</a></code> before this function can resolve this ambiguity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the Array from which the element is being removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element, or NULL if the operation has failed </dd></dl>

</div>
</div>
<a class="anchor" id="ab2b26295477a6717a4708776952db5f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_remove_all </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the specified array. </p>
<p>This function does not shrink the array capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array from which all elements are to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca98ad1af5fdce9d540011cf4751b3b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_remove_all_free </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and frees all elements from the specified array. </p>
<p>This function does not shrink the array capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array from which all elements are to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad43c253f048caaa4bb81d579ca99e31b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* array_remove_at </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns a array element from the specified index. </p>
<p>The index must be within the bounds of the array, otherwise NULL is returned. NULL may also be returned if the removed element was NULL. To resolve this ambiguity call <code><a class="el" href="array_8c.html#a42c462b132d8ea30c69d7d3281d27abe" title="Returns the number of occurrences of the element within the specified array. ">array_contains()</a></code> before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array from which the element is being removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of the element being removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element, or NULL if the operation fails </dd></dl>

</div>
</div>
<a class="anchor" id="a277be752070ce86b6f410e0da862648c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* array_remove_last </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns a array element from the end of the array. </p>
<p>Or NULL if array is empty. NULL may also be returned if the last element of the array is NULL value. This ambiguity can be resolved by calling <code><a class="el" href="array_8c.html#a1642fa6d156a8ba9c9e77d9f9883bc01" title="Returns the size of the specified array. ">array_size()</a> </code>before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array whose last element is being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last element of the array ie. the element at the highest index </dd></dl>

</div>
</div>
<a class="anchor" id="a819f1da2f6e026dcd71b12aa78a5a98b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* array_replace_at </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a array element at the specified index and returns the replaced element. </p>
<p>The specified index must be within the bounds of the Array, otherwise NULL is returned. NULL can also be returned if the replaced element was NULL. In this case calling <code><a class="el" href="array_8c.html#a42c462b132d8ea30c69d7d3281d27abe" title="Returns the number of occurrences of the element within the specified array. ">array_contains()</a></code> before this function can resolve this ambiguity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the Array whose element is being replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the replacement element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index at which the replacement element should be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the replaced element or NULL if the index was out of bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="a72ef0dd25e5f57ffcaa9de1c4a4dd2d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_reverse </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the order of elements in the specified array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array that is being reversed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1642fa6d156a8ba9c9e77d9f9883bc01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t array_size </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the specified array. </p>
<p>The size of the array is the number of elements contained within the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array whose size is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the the number of element within the array </dd></dl>

</div>
</div>
<a class="anchor" id="a0da93b02bbb9e5292b2e9378f1c7260d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_sort </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the specified array. </p>
<dl class="section note"><dt>Note</dt><dd>Pointers passed to the comparator function will be pointers to the array elements that are of type (void*) ie. void**. So an extra step of dereferencing will be required before the data can be used for comparison: eg. <code>my_type e = *(*((my_type**) ptr));</code>.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int mycmp(const void *e1, const void *e2) {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    MyType el1 = *(*((int**) e1));</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    MyType el2 = *(*((int**) e2));</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if (el1 &lt; el2) return -1;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    if (el1 &gt; el2) return 1;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    return 0;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;...</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;array_sort(array, mycmp);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>array to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>the comparator function that must be of type <code> int cmp(const void e1*, const void e2*)</code> that returns &lt; 0 if the first element goes before the second, 0 if the elements are equal and &gt; 0 if the second goes before the first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af022b124faef5b1074ed55b79b0d076e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array* array_subarray </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a subarray of the specified array, randing from <code>b</code> index (inclusive) to <code>e</code> index (inclusive). </p>
<p>The range indices must be within the bounds of the array, while the <code>e</code> index must be greater or equal to the <code>b</code> index. If these conditions not met, NULL is returned.</p>
<dl class="section note"><dt>Note</dt><dd>The new array is allocated using the original arrays allocators and also inherits the configuration of the original array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array from which the subarray is being returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the beginning index (inclusive) of the subarray that must be within the bounds of the array and must not exceed the the end index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the end index (inclusive) of the subarray that must be within the bounds of the array and must be greater or equal to the beginnig index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a subarray of the specified array, or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a1a526de0a359cd5a6d3784ebd5afe4c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_trim_capacity </td>
          <td>(</td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the array's capacity, in other words, it shrinks the capacity to match the number of elements in the specified array, however the capacity will never shrink below 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>the array whose capacity is being trimmed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 12 2015 14:58:15 for Collections-C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
