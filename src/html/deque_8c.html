<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Collections-C: deque.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Collections-C
   </div>
   <div id="projectbrief">A library of generic container types.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">deque.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="deque_8h_source.html">deque.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdeque__s.html">Deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic array that supports amortized constant time insertion and removal at both ends and constant time access.  <a href="structdeque__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2af6bf843475565a9681f9449a3d5cc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a2af6bf843475565a9681f9449a3d5cc2">DEFAULT_CAPACITY</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a2af6bf843475565a9681f9449a3d5cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36982708a1a76345461d2ecebb3e92e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#ac36982708a1a76345461d2ecebb3e92e">DEFAULT_EXPANSION_FACTOR</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac36982708a1a76345461d2ecebb3e92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a46400a135a93c70be8166a1392e658b4"><td class="memItemLeft" align="right" valign="top">Deque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a46400a135a93c70be8166a1392e658b4">deque_new</a> ()</td></tr>
<tr class="memdesc:a46400a135a93c70be8166a1392e658b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new empty deque, or NULL if the allocation fails.  <a href="#a46400a135a93c70be8166a1392e658b4">More...</a><br /></td></tr>
<tr class="separator:a46400a135a93c70be8166a1392e658b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afead3067f10e29c66cfa794314e93c5f"><td class="memItemLeft" align="right" valign="top">Deque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#afead3067f10e29c66cfa794314e93c5f">deque_new_conf</a> (<a class="el" href="structDequeConf.html">DequeConf</a> *conf)</td></tr>
<tr class="memdesc:afead3067f10e29c66cfa794314e93c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new empty deque based on the specified <a class="el" href="structDequeConf.html" title="Deque configuration object. ">DequeConf</a> object.  <a href="#afead3067f10e29c66cfa794314e93c5f">More...</a><br /></td></tr>
<tr class="separator:afead3067f10e29c66cfa794314e93c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabf96a1f67880c9f8be81c81088beb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#afabf96a1f67880c9f8be81c81088beb9">deque_conf_init</a> (<a class="el" href="structDequeConf.html">DequeConf</a> *conf)</td></tr>
<tr class="memdesc:afabf96a1f67880c9f8be81c81088beb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the fields of the <a class="el" href="structDequeConf.html" title="Deque configuration object. ">DequeConf</a> struct to default values.  <a href="#afabf96a1f67880c9f8be81c81088beb9">More...</a><br /></td></tr>
<tr class="separator:afabf96a1f67880c9f8be81c81088beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f95e1ca7aee51075134a998cda7e75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a75f95e1ca7aee51075134a998cda7e75">deque_destroy</a> (Deque *deque)</td></tr>
<tr class="memdesc:a75f95e1ca7aee51075134a998cda7e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the deque structure, but leaves the data it used to hold, intact.  <a href="#a75f95e1ca7aee51075134a998cda7e75">More...</a><br /></td></tr>
<tr class="separator:a75f95e1ca7aee51075134a998cda7e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eef16da4dd429cee060b64ddb89faf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a6eef16da4dd429cee060b64ddb89faf0">deque_destroy_free</a> (Deque *deque)</td></tr>
<tr class="memdesc:a6eef16da4dd429cee060b64ddb89faf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the deque structure along with all the data it holds.  <a href="#a6eef16da4dd429cee060b64ddb89faf0">More...</a><br /></td></tr>
<tr class="separator:a6eef16da4dd429cee060b64ddb89faf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357fa89b1bd763df3e942b4b79861e38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a357fa89b1bd763df3e942b4b79861e38">deque_add</a> (Deque *deque, void *element)</td></tr>
<tr class="memdesc:a357fa89b1bd763df3e942b4b79861e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the deque.  <a href="#a357fa89b1bd763df3e942b4b79861e38">More...</a><br /></td></tr>
<tr class="separator:a357fa89b1bd763df3e942b4b79861e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe9a98af9c80496fcfbc1df7b12aafe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#adbe9a98af9c80496fcfbc1df7b12aafe">deque_add_first</a> (Deque *deque, void *element)</td></tr>
<tr class="memdesc:adbe9a98af9c80496fcfbc1df7b12aafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the front of the deque.  <a href="#adbe9a98af9c80496fcfbc1df7b12aafe">More...</a><br /></td></tr>
<tr class="separator:adbe9a98af9c80496fcfbc1df7b12aafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9d84fabdd24d4e03e7f6970607ba9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a3e9d84fabdd24d4e03e7f6970607ba9f">deque_add_last</a> (Deque *deque, void *element)</td></tr>
<tr class="memdesc:a3e9d84fabdd24d4e03e7f6970607ba9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the back of the deque.  <a href="#a3e9d84fabdd24d4e03e7f6970607ba9f">More...</a><br /></td></tr>
<tr class="separator:a3e9d84fabdd24d4e03e7f6970607ba9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8200bad683184e7748359560c185e69f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a8200bad683184e7748359560c185e69f">deque_add_at</a> (Deque *deque, void *element, size_t index)</td></tr>
<tr class="memdesc:a8200bad683184e7748359560c185e69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at the specified index within the deque.  <a href="#a8200bad683184e7748359560c185e69f">More...</a><br /></td></tr>
<tr class="separator:a8200bad683184e7748359560c185e69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bb49738b0db0ce2d1becbfef0a0165"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a94bb49738b0db0ce2d1becbfef0a0165">deque_replace_at</a> (Deque *deque, void *element, size_t index)</td></tr>
<tr class="memdesc:a94bb49738b0db0ce2d1becbfef0a0165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a deque element at the specified index and returns the replaced element.  <a href="#a94bb49738b0db0ce2d1becbfef0a0165">More...</a><br /></td></tr>
<tr class="separator:a94bb49738b0db0ce2d1becbfef0a0165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d26ac1c9f6b1c4ea13879e84bdab699"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a7d26ac1c9f6b1c4ea13879e84bdab699">deque_remove</a> (Deque *deque, void *element)</td></tr>
<tr class="memdesc:a7d26ac1c9f6b1c4ea13879e84bdab699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the specified element from the deque if such element exists.  <a href="#a7d26ac1c9f6b1c4ea13879e84bdab699">More...</a><br /></td></tr>
<tr class="separator:a7d26ac1c9f6b1c4ea13879e84bdab699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad916fcfbdd5711f8965f93445d0c69a1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#ad916fcfbdd5711f8965f93445d0c69a1">deque_remove_at</a> (Deque *deque, size_t index)</td></tr>
<tr class="memdesc:ad916fcfbdd5711f8965f93445d0c69a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns a deque element from the specified index.  <a href="#ad916fcfbdd5711f8965f93445d0c69a1">More...</a><br /></td></tr>
<tr class="separator:ad916fcfbdd5711f8965f93445d0c69a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19b891f5ad9b991f145c0298bb6102f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#ab19b891f5ad9b991f145c0298bb6102f">deque_remove_first</a> (Deque *deque)</td></tr>
<tr class="memdesc:ab19b891f5ad9b991f145c0298bb6102f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the element from the front of the deque, or NULL if the deque is empty.  <a href="#ab19b891f5ad9b991f145c0298bb6102f">More...</a><br /></td></tr>
<tr class="separator:ab19b891f5ad9b991f145c0298bb6102f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ec80aa60f30e4b12958069bd9b9596"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a68ec80aa60f30e4b12958069bd9b9596">deque_remove_last</a> (Deque *deque)</td></tr>
<tr class="memdesc:a68ec80aa60f30e4b12958069bd9b9596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the element from the back of the deque, or NULL if the deque is empty.  <a href="#a68ec80aa60f30e4b12958069bd9b9596">More...</a><br /></td></tr>
<tr class="separator:a68ec80aa60f30e4b12958069bd9b9596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc3724111c9456cf5f0241b1f62b79b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a5bc3724111c9456cf5f0241b1f62b79b">deque_remove_all</a> (Deque *deque)</td></tr>
<tr class="memdesc:a5bc3724111c9456cf5f0241b1f62b79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the specified deque.  <a href="#a5bc3724111c9456cf5f0241b1f62b79b">More...</a><br /></td></tr>
<tr class="separator:a5bc3724111c9456cf5f0241b1f62b79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82341a76fbca3f38da9d147826917a09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a82341a76fbca3f38da9d147826917a09">deque_remove_all_free</a> (Deque *deque)</td></tr>
<tr class="memdesc:a82341a76fbca3f38da9d147826917a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and frees all element from the specified deque.  <a href="#a82341a76fbca3f38da9d147826917a09">More...</a><br /></td></tr>
<tr class="separator:a82341a76fbca3f38da9d147826917a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111a385f398b487be784974bc73874a0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a111a385f398b487be784974bc73874a0">deque_get</a> (Deque *deque, size_t index)</td></tr>
<tr class="memdesc:a111a385f398b487be784974bc73874a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a deque element from the specified index.  <a href="#a111a385f398b487be784974bc73874a0">More...</a><br /></td></tr>
<tr class="separator:a111a385f398b487be784974bc73874a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43992edcd8aaa7b35fc94834a2d288ef"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a43992edcd8aaa7b35fc94834a2d288ef">deque_get_first</a> (Deque *deque)</td></tr>
<tr class="memdesc:a43992edcd8aaa7b35fc94834a2d288ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first (head) element of the deque or NULL if the deque is empty.  <a href="#a43992edcd8aaa7b35fc94834a2d288ef">More...</a><br /></td></tr>
<tr class="separator:a43992edcd8aaa7b35fc94834a2d288ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3e66468d4905b17194798e1a4974ac"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a8a3e66468d4905b17194798e1a4974ac">deque_get_last</a> (Deque *deque)</td></tr>
<tr class="memdesc:a8a3e66468d4905b17194798e1a4974ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last (tail) element of the deque or NULL if the deque is empty.  <a href="#a8a3e66468d4905b17194798e1a4974ac">More...</a><br /></td></tr>
<tr class="separator:a8a3e66468d4905b17194798e1a4974ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e35bb04356099d748c4243dca0b6054"><td class="memItemLeft" align="right" valign="top">Deque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a3e35bb04356099d748c4243dca0b6054">deque_copy_shallow</a> (Deque *deque)</td></tr>
<tr class="memdesc:a3e35bb04356099d748c4243dca0b6054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shallow copy of the specified deque.  <a href="#a3e35bb04356099d748c4243dca0b6054">More...</a><br /></td></tr>
<tr class="separator:a3e35bb04356099d748c4243dca0b6054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae821aa18c7c3d9424be081cd2c591d67"><td class="memItemLeft" align="right" valign="top">Deque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#ae821aa18c7c3d9424be081cd2c591d67">deque_copy_deep</a> (Deque *deque, void *(*cp)(void *))</td></tr>
<tr class="memdesc:ae821aa18c7c3d9424be081cd2c591d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a deep copy of the specified deque.  <a href="#ae821aa18c7c3d9424be081cd2c591d67">More...</a><br /></td></tr>
<tr class="separator:ae821aa18c7c3d9424be081cd2c591d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79457668842671748d7f625dfbb9903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#af79457668842671748d7f625dfbb9903">deque_trim_capacity</a> (Deque *deque)</td></tr>
<tr class="memdesc:af79457668842671748d7f625dfbb9903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the capacity of the deque to a power of 2 that is the nearest to the number of elements in the deque.  <a href="#af79457668842671748d7f625dfbb9903">More...</a><br /></td></tr>
<tr class="separator:af79457668842671748d7f625dfbb9903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812514fb00dccb2444cccc6fea8c3a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a812514fb00dccb2444cccc6fea8c3a8f">deque_reverse</a> (Deque *deque)</td></tr>
<tr class="memdesc:a812514fb00dccb2444cccc6fea8c3a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of elements in the specified deque.  <a href="#a812514fb00dccb2444cccc6fea8c3a8f">More...</a><br /></td></tr>
<tr class="separator:a812514fb00dccb2444cccc6fea8c3a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3e33fbb3dca64b0161636a72a70421"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a8d3e33fbb3dca64b0161636a72a70421">deque_contains</a> (Deque *deque, void *element)</td></tr>
<tr class="memdesc:a8d3e33fbb3dca64b0161636a72a70421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of occurrences of the element within the specified deque.  <a href="#a8d3e33fbb3dca64b0161636a72a70421">More...</a><br /></td></tr>
<tr class="separator:a8d3e33fbb3dca64b0161636a72a70421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fb8f5bc982658486b4d213daad4c8e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a54fb8f5bc982658486b4d213daad4c8e">deque_index_of</a> (Deque *deque, void *element)</td></tr>
<tr class="memdesc:a54fb8f5bc982658486b4d213daad4c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first occurence of the specified deque element, or NO_SUCH_INDEX if the element could not be found.  <a href="#a54fb8f5bc982658486b4d213daad4c8e">More...</a><br /></td></tr>
<tr class="separator:a54fb8f5bc982658486b4d213daad4c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6628e1ad1ca591098aa3d86ce0b4d30e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a6628e1ad1ca591098aa3d86ce0b4d30e">deque_size</a> (Deque *deque)</td></tr>
<tr class="memdesc:a6628e1ad1ca591098aa3d86ce0b4d30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the specified deque.  <a href="#a6628e1ad1ca591098aa3d86ce0b4d30e">More...</a><br /></td></tr>
<tr class="separator:a6628e1ad1ca591098aa3d86ce0b4d30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84a8e47c81748aa87f8ea9b3ba8f337"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#ad84a8e47c81748aa87f8ea9b3ba8f337">deque_capacity</a> (Deque *deque)</td></tr>
<tr class="memdesc:ad84a8e47c81748aa87f8ea9b3ba8f337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retruns the capacity of the specified deque.  <a href="#ad84a8e47c81748aa87f8ea9b3ba8f337">More...</a><br /></td></tr>
<tr class="separator:ad84a8e47c81748aa87f8ea9b3ba8f337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac094377bd307a7791800b68cb114498"><td class="memItemLeft" align="right" valign="top">const void *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#aac094377bd307a7791800b68cb114498">deque_get_buffer</a> (Deque *deque)</td></tr>
<tr class="memdesc:aac094377bd307a7791800b68cb114498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the underlying deque buffer.  <a href="#aac094377bd307a7791800b68cb114498">More...</a><br /></td></tr>
<tr class="separator:aac094377bd307a7791800b68cb114498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cd6ede0517e9873c3d5da642d6975b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#ab3cd6ede0517e9873c3d5da642d6975b">deque_foreach</a> (Deque *deque, void(*op)(void *))</td></tr>
<tr class="memdesc:ab3cd6ede0517e9873c3d5da642d6975b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 'foreach loop' function that invokes the specified function on each element of the deque.  <a href="#ab3cd6ede0517e9873c3d5da642d6975b">More...</a><br /></td></tr>
<tr class="separator:ab3cd6ede0517e9873c3d5da642d6975b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29412a69b7c336cad1d3894639d4d16b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a29412a69b7c336cad1d3894639d4d16b">deque_iter_init</a> (<a class="el" href="structDequeIter.html">DequeIter</a> *iter, Deque *deque)</td></tr>
<tr class="memdesc:a29412a69b7c336cad1d3894639d4d16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the iterator.  <a href="#a29412a69b7c336cad1d3894639d4d16b">More...</a><br /></td></tr>
<tr class="separator:a29412a69b7c336cad1d3894639d4d16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb7d7665d36c5c66e703cdd476555a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a0fb7d7665d36c5c66e703cdd476555a3">deque_iter_has_next</a> (<a class="el" href="structDequeIter.html">DequeIter</a> *iter)</td></tr>
<tr class="memdesc:a0fb7d7665d36c5c66e703cdd476555a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks wheteher or not the iterator has reached the end of the deque.  <a href="#a0fb7d7665d36c5c66e703cdd476555a3">More...</a><br /></td></tr>
<tr class="separator:a0fb7d7665d36c5c66e703cdd476555a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07ca4966b0051c86d7abf1cf93bcf79"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79">deque_iter_next</a> (<a class="el" href="structDequeIter.html">DequeIter</a> *iter)</td></tr>
<tr class="memdesc:ab07ca4966b0051c86d7abf1cf93bcf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next element in the sequence and advances the iterator.  <a href="#ab07ca4966b0051c86d7abf1cf93bcf79">More...</a><br /></td></tr>
<tr class="separator:ab07ca4966b0051c86d7abf1cf93bcf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9553c4915975de166da5a1e0a013c4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#afb9553c4915975de166da5a1e0a013c4">deque_iter_remove</a> (<a class="el" href="structDequeIter.html">DequeIter</a> *iter)</td></tr>
<tr class="memdesc:afb9553c4915975de166da5a1e0a013c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the last returned element by <code><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79" title="Returns the next element in the sequence and advances the iterator. ">deque_iter_next()</a> </code> without invalidating the iterator.  <a href="#afb9553c4915975de166da5a1e0a013c4">More...</a><br /></td></tr>
<tr class="separator:afb9553c4915975de166da5a1e0a013c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e97148e2c21516b59e78da589e55dbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a3e97148e2c21516b59e78da589e55dbe">deque_iter_add</a> (<a class="el" href="structDequeIter.html">DequeIter</a> *iter, void *element)</td></tr>
<tr class="memdesc:a3e97148e2c21516b59e78da589e55dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element tothe deque after the last returned element by <code><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79" title="Returns the next element in the sequence and advances the iterator. ">deque_iter_next()</a></code> without invalidating the iterator.  <a href="#a3e97148e2c21516b59e78da589e55dbe">More...</a><br /></td></tr>
<tr class="separator:a3e97148e2c21516b59e78da589e55dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47089d42d77120c6dad9e293ae38b169"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a47089d42d77120c6dad9e293ae38b169">deque_iter_replace</a> (<a class="el" href="structDequeIter.html">DequeIter</a> *iter, void *replacement)</td></tr>
<tr class="memdesc:a47089d42d77120c6dad9e293ae38b169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the last returned element by <code><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79" title="Returns the next element in the sequence and advances the iterator. ">deque_iter_next()</a></code> with the specified replacement element.  <a href="#a47089d42d77120c6dad9e293ae38b169">More...</a><br /></td></tr>
<tr class="separator:a47089d42d77120c6dad9e293ae38b169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902f9e38749de307daa554e94084133f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8c.html#a902f9e38749de307daa554e94084133f">deque_iter_index</a> (<a class="el" href="structDequeIter.html">DequeIter</a> *iter)</td></tr>
<tr class="memdesc:a902f9e38749de307daa554e94084133f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last returned element by <code><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79" title="Returns the next element in the sequence and advances the iterator. ">deque_iter_next()</a> </code>.  <a href="#a902f9e38749de307daa554e94084133f">More...</a><br /></td></tr>
<tr class="separator:a902f9e38749de307daa554e94084133f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a2af6bf843475565a9681f9449a3d5cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_CAPACITY&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac36982708a1a76345461d2ecebb3e92e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_EXPANSION_FACTOR&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a357fa89b1bd763df3e942b4b79861e38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deque_add </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the deque. </p>
<p>The element is appended to the tail of the deque. This function returns a <code>bool</code> based on whether or not the space allocation for the new element was successful or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element that is being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a8200bad683184e7748359560c185e69f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deque_add_at </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element at the specified index within the deque. </p>
<p>The index must be within the range of the deque. This function may also fail if the memory allocation for the new element was not successful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque to which this new element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element that is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the position within the dequeu at which this new element is is being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="adbe9a98af9c80496fcfbc1df7b12aafe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deque_add_first </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the front of the deque. </p>
<p>This function returns a <code>bool</code> based on whether the memory allocation for the new element was successful or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element that is being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a3e9d84fabdd24d4e03e7f6970607ba9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deque_add_last </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element to the back of the deque. </p>
<p>This function returns a <code>bool</code> based on whether the memory allocation for the new element was successful or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque to which the element is being added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element that is being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="ad84a8e47c81748aa87f8ea9b3ba8f337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t deque_capacity </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retruns the capacity of the specified deque. </p>
<p>The capacity of the deque is the maximum number of elements a deque can hold before it's underlying buffer needs to be resized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>deque whose capacity is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity of the specified deque </dd></dl>

</div>
</div>
<a class="anchor" id="afabf96a1f67880c9f8be81c81088beb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_conf_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDequeConf.html">DequeConf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the fields of the <a class="el" href="structDequeConf.html" title="Deque configuration object. ">DequeConf</a> struct to default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">conf</td><td>the configuration object that is being initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d3e33fbb3dca64b0161636a72a70421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t deque_contains </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of occurrences of the element within the specified deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque that is being searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element that is being searched for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of occurrences of the element </dd></dl>

</div>
</div>
<a class="anchor" id="ae821aa18c7c3d9424be081cd2c591d67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Deque* deque_copy_deep </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a deep copy of the specified deque. </p>
<p>A deep copy is a copy of both the deque structure and the data it holds.</p>
<dl class="section note"><dt>Note</dt><dd>The new deque is allocated using the original deque's allocators and also inherits the configuration of the original deque.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>the copy function that returns a copy of a deque element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deep copy of the specified deque </dd></dl>

</div>
</div>
<a class="anchor" id="a3e35bb04356099d748c4243dca0b6054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Deque* deque_copy_shallow </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a shallow copy of the specified deque. </p>
<p>A shallow copy is a copy of the deque structure, but not the elements it holds.</p>
<dl class="section note"><dt>Note</dt><dd>The new deque is allocated using the original deque's allocators and also inherits the configuration of the original deque.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shallow copy of the specified deque </dd></dl>

</div>
</div>
<a class="anchor" id="a75f95e1ca7aee51075134a998cda7e75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_destroy </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the deque structure, but leaves the data it used to hold, intact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque that is to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6eef16da4dd429cee060b64ddb89faf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_destroy_free </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the deque structure along with all the data it holds. </p>
<dl class="section note"><dt>Note</dt><dd>This function should not be called on a deque that has some of its elements allocated on the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque that is being destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3cd6ede0517e9873c3d5da642d6975b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_foreach </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 'foreach loop' function that invokes the specified function on each element of the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque on which this operation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>the operation function that is to be invoked on each deque element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a111a385f398b487be784974bc73874a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_get </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a deque element from the specified index. </p>
<p>The specified index must be withing the bounds of the deque, otherwise NULL is returned. NULL can also be returned if the element at the specified index is NULL. This ambiguity can be resolved by calling <code><a class="el" href="deque_8c.html#a8d3e33fbb3dca64b0161636a72a70421" title="Returns the number of occurrences of the element within the specified deque. ">deque_contains()</a></code> before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque from which the element is being returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of the deque element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element at the specified index, or NULL if the operation has failed. </dd></dl>

</div>
</div>
<a class="anchor" id="aac094377bd307a7791800b68cb114498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* const* deque_get_buffer </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the underlying deque buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque whose underlying buffer is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a43992edcd8aaa7b35fc94834a2d288ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_get_first </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first (head) element of the deque or NULL if the deque is empty. </p>
<p>NULL may also be returned if the first element of the deque is of NULL value. This ambiguity can be resolved by calling <code><a class="el" href="deque_8c.html#a6628e1ad1ca591098aa3d86ce0b4d30e" title="Returns the size of the specified deque. ">deque_size()</a></code> before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque whose first element is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first element of the specified deque </dd></dl>

</div>
</div>
<a class="anchor" id="a8a3e66468d4905b17194798e1a4974ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_get_last </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last (tail) element of the deque or NULL if the deque is empty. </p>
<p>NULL may also be returned if the first element of the deque is of NULL value. This ambiguity can be resolved by calling <code><a class="el" href="deque_8c.html#a6628e1ad1ca591098aa3d86ce0b4d30e" title="Returns the size of the specified deque. ">deque_size()</a></code> before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque whose last element is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last element of the specified deque </dd></dl>

</div>
</div>
<a class="anchor" id="a54fb8f5bc982658486b4d213daad4c8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t deque_index_of </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the first occurence of the specified deque element, or NO_SUCH_INDEX if the element could not be found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>deque being searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element whose index is being looked up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the specified element, or NO_SUCH_INDEX if the element is not found </dd></dl>

</div>
</div>
<a class="anchor" id="a3e97148e2c21516b59e78da589e55dbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deque_iter_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDequeIter.html">DequeIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element tothe deque after the last returned element by <code><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79" title="Returns the next element in the sequence and advances the iterator. ">deque_iter_next()</a></code> without invalidating the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element being added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the elmenet was successfully added or false if the allocation for the new element failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0fb7d7665d36c5c66e703cdd476555a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deque_iter_has_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDequeIter.html">DequeIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks wheteher or not the iterator has reached the end of the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>iterator whose position is being checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are more elemnets to be iterated over </dd></dl>

</div>
</div>
<a class="anchor" id="a902f9e38749de307daa554e94084133f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t deque_iter_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDequeIter.html">DequeIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the last returned element by <code><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79" title="Returns the next element in the sequence and advances the iterator. ">deque_iter_next()</a> </code>. </p>
<dl class="section note"><dt>Note</dt><dd>This function should not be called before a call to <code><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79" title="Returns the next element in the sequence and advances the iterator. ">deque_iter_next()</a> </code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index </dd></dl>

</div>
</div>
<a class="anchor" id="a29412a69b7c336cad1d3894639d4d16b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_iter_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDequeIter.html">DequeIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator that is being initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the vector to iterate over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab07ca4966b0051c86d7abf1cf93bcf79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_iter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDequeIter.html">DequeIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next element in the sequence and advances the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator that is being advanced</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next element in the sequence </dd></dl>

</div>
</div>
<a class="anchor" id="afb9553c4915975de166da5a1e0a013c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_iter_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDequeIter.html">DequeIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the last returned element by <code><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79" title="Returns the next element in the sequence and advances the iterator. ">deque_iter_next()</a> </code> without invalidating the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being perfrormed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element </dd></dl>

</div>
</div>
<a class="anchor" id="a47089d42d77120c6dad9e293ae38b169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_iter_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDequeIter.html">DequeIter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the last returned element by <code><a class="el" href="deque_8c.html#ab07ca4966b0051c86d7abf1cf93bcf79" title="Returns the next element in the sequence and advances the iterator. ">deque_iter_next()</a></code> with the specified replacement element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the iterator on which this operation is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>the replacement element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old element that was replaced </dd></dl>

</div>
</div>
<a class="anchor" id="a46400a135a93c70be8166a1392e658b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Deque* deque_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new empty deque, or NULL if the allocation fails. </p>
<dl class="section return"><dt>Returns</dt><dd>a new deque if the allocation was successful, or NULL if it was not. </dd></dl>

</div>
</div>
<a class="anchor" id="afead3067f10e29c66cfa794314e93c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Deque* deque_new_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDequeConf.html">DequeConf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new empty deque based on the specified <a class="el" href="structDequeConf.html" title="Deque configuration object. ">DequeConf</a> object. </p>
<p>The deque is allocated using the allocators specified the <a class="el" href="structDequeConf.html" title="Deque configuration object. ">DequeConf</a> object The allocation may fail if the underlying allocator fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>Deque configuration object. All fields must be initialized appropriate values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new deque if the allocation was successful, or NULL if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d26ac1c9f6b1c4ea13879e84bdab699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_remove </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the specified element from the deque if such element exists. </p>
<p>In case the element doesn't exist NULL is retruned. NULL may also be returned if the specified element is NULL. In this case calling <code> <a class="el" href="deque_8c.html#a8d3e33fbb3dca64b0161636a72a70421" title="Returns the number of occurrences of the element within the specified deque. ">deque_contains()</a></code> before this function can resolve the ambiguity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque from which the element is being removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the element being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>removed element, or NULL if the operation fails </dd></dl>

</div>
</div>
<a class="anchor" id="a5bc3724111c9456cf5f0241b1f62b79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_remove_all </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the specified deque. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not shrink the deque capacity.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque from which all element are being removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82341a76fbca3f38da9d147826917a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_remove_all_free </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and frees all element from the specified deque. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not shrink the deque capacity. </dd>
<dd>
This function should not be called on deques that have some of their element allocated on the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque from which all elements are being removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad916fcfbdd5711f8965f93445d0c69a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_remove_at </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns a deque element from the specified index. </p>
<p>The index must be within the bounds of the deque, otherwise NULL is returned. NULL may also be returned if the removed element was NULL. To resolve this ambiguity call <code><a class="el" href="deque_8c.html#a8d3e33fbb3dca64b0161636a72a70421" title="Returns the number of occurrences of the element within the specified deque. ">deque_contains()</a></code> before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque from which the element is being removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of the element being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element, or NULL if the operation fails </dd></dl>

</div>
</div>
<a class="anchor" id="ab19b891f5ad9b991f145c0298bb6102f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_remove_first </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the element from the front of the deque, or NULL if the deque is empty. </p>
<p>NULL may also be returned if the first element in the deque is of NULL value. This ambiguity can be resolved by calling <code><a class="el" href="deque_8c.html#a6628e1ad1ca591098aa3d86ce0b4d30e" title="Returns the size of the specified deque. ">deque_size()</a></code> before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque whose first element (or head) is being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element </dd></dl>

</div>
</div>
<a class="anchor" id="a68ec80aa60f30e4b12958069bd9b9596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_remove_last </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the element from the back of the deque, or NULL if the deque is empty. </p>
<p>NULL may also be returned if the last element in the deque is of NULL value. This ambiguity can be resolved by calling <code> <a class="el" href="deque_8c.html#a6628e1ad1ca591098aa3d86ce0b4d30e" title="Returns the size of the specified deque. ">deque_size()</a></code> before this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque whose last element (or tail) is being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed element </dd></dl>

</div>
</div>
<a class="anchor" id="a94bb49738b0db0ce2d1becbfef0a0165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* deque_replace_at </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a deque element at the specified index and returns the replaced element. </p>
<p>The specified index must be within the bounds of the deque, otherwise NULL is returned. NULL may also be returned if the replaced element was NULL. In this case calling <code><a class="el" href="deque_8c.html#a8d3e33fbb3dca64b0161636a72a70421" title="Returns the number of occurrences of the element within the specified deque. ">deque_contains()</a></code> before this function can resolve this ambiguity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque whose element is being replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>the replacement element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index at which the replacement element should be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replaced element, or NULL if the index was out of bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="a812514fb00dccb2444cccc6fea8c3a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_reverse </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the order of elements in the specified deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque that is being reversed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6628e1ad1ca591098aa3d86ce0b4d30e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t deque_size </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the specified deque. </p>
<p>The size of the deque is the number of element contained within the deque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque whose size is being returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of element within the specified deque </dd></dl>

</div>
</div>
<a class="anchor" id="af79457668842671748d7f625dfbb9903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_trim_capacity </td>
          <td>(</td>
          <td class="paramtype">Deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the capacity of the deque to a power of 2 that is the nearest to the number of elements in the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deque</td><td>the deque on which this operation is being performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 12 2015 14:58:15 for Collections-C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
