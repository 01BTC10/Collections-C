<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;c&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" />
        <div class="lang-selector">
              <a href="#" data-language-name="c">c</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='https://github.com/tripit/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>Welcome to the Collections C documentation.</p>

          <h1 id="array">Array</h1>

<h2 id="array_new">array_new</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">status</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>


<span class="c1">// Check if the array was initialized correctly
</span><span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">CC_ERR_ALLOC</span><span class="p">)</span>
    <span class="p">...</span>
</code></pre>

<p>New arrays can be created with <code class="prettyprint">array_new</code>. This will create a new empty array with default parameters. <code class="prettyprint">array_new</code> takes a pointer to a pointer to an Array structure and initializes it with the new Array and then returns a status code to indicate success or failure. </p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_new(Array**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array**</td>
<td>out</td>
<td>Pointer to an array that is being initialized</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the array was successfully initialized</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation failed</td>
</tr>
</tbody></table>

<h2 id="arrayconf">ArrayConf</h2>
<pre class="highlight c"><code><span class="n">ArrayConf</span> <span class="n">ac</span><span class="p">;</span>

<span class="c1">// Initialize all fields to default values
</span><span class="n">array_conf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>


<span class="c1">// change the default initial capacity
</span><span class="n">ac</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>


<span class="c1">// Now we can create a new array with an initial capacity of 100
</span><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">s</span> <span class="o">=</span> <span class="n">array_new_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>
</code></pre>

<p>ArrayConf struct lets you pass additional parameters when creating a new Array.</p>

<p>Perhaps you would like to initialize the array with a different initial capacity, or perhaps you might want to change the rate at which the array buffer grows. To do this you can pass a <code class="prettyprint">ArrayConf</code> struct to <code class="prettyprint">array_new_conf()</code> to get new customized Array.</p>

<p>To use the <code class="prettyprint">ArrayConf</code> struct we first initialize all of its fields to default values with <code class="prettyprint">array_conf_init(ArrayConf*)</code>, and then we overwrite individual fields that we&rsquo;re interested in.</p>

<p>If we simply passed <code class="prettyprint">ArrayConf</code> to <code class="prettyprint">array_conf_new()</code> after initializing it with <code class="prettyprint">array_conf_init</code> without changing any values, it would have the same effect as calling <code class="prettyprint">array_new()</code> without using the configuration struct.</p>

<h3 id="struct">Struct</h3>

<p><code class="prettyprint">ArrayConf</code></p>

<table><thead>
<tr>
<th>field</th>
<th>type</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>capacity</td>
<td>size_t</td>
<td>The initial capacity of the newly created array</td>
</tr>
<tr>
<td>exp_factor</td>
<td>float</td>
<td>The rate at which the internal buffer expands (capacity * exp_factor). For example if the exp_factor is set to 0.5, then the internal buffer would grow by 50% on each resize.</td>
</tr>
<tr>
<td>mem_alloc</td>
<td>void <em>(</em>) (size_t)</td>
<td>Pointer to a user specified &ldquo;malloc&rdquo;</td>
</tr>
<tr>
<td>mem_calloc</td>
<td>void*(*) (size_t, size_t)</td>
<td>Pointer to a user specified &ldquo;calloc&rdquo;</td>
</tr>
<tr>
<td>mem_free</td>
<td>void (<em>) (void</em>)</td>
<td>Pointer to a user specified &ldquo;free&rdquo;</td>
</tr>
</tbody></table>

<aside class="warning"> Make sure that all fields are initialized before passing it to <b>array_new_conf()</b> either by manually setting each field or by initializing the struct with <b>array_conf_init()</b>. </aside>

<h2 id="array_new_conf">array_new_conf</h2>
<pre class="highlight c"><code><span class="n">ArrayConf</span> <span class="n">conf</span><span class="p">;</span>
<span class="n">array_conf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>

<span class="n">conf</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="n">conf</span><span class="p">.</span><span class="n">exp_factor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="n">f</span><span class="p">;</span>

<span class="c1">// Create a new array with with additional parameters
</span><span class="n">Array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">status</span> <span class="o">=</span> <span class="n">array_new_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>

<span class="c1">// Handle errors
</span><span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">CC_ERR_ALLOC</span><span class="p">)</span>
    <span class="p">...</span>

</code></pre>

<p>Arrays can be created with additional parameters by calling <code class="prettyprint">array_new_conf</code> instead of <code class="prettyprint">array_new</code>. The <code class="prettyprint">array_new_conf</code> function takes a pointer to a pointer to an Array structure and also a pointer to an <code class="prettyprint">ArrayConf</code> structure through which additional parameters are passed. <code class="prettyprint">array_new_conf</code> returns a status code to indicate success or failure.</p>

<p>The array is allocated using the allocators passed in by <code class="prettyprint">ArrayConf</code>.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_new_conf(const ArrayConf const*, Array**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>const ArrayConf const*</td>
<td>in</td>
<td>Pointer to a config struct</td>
</tr>
<tr>
<td>2</td>
<td>Array**</td>
<td>out</td>
<td>Pointer to an array that is being initialized</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the array was successfully initialized</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation failed</td>
</tr>
<tr>
<td>CC_ERR_INVALID_CAPACITY</td>
<td>if the capacity in the <code class="prettyprint">ArrayConf</code> does not meet the following condition: <code class="prettyprint">exp_factor &lt; (CC_MAX_ELEMENTS / capacity)</code></td>
</tr>
</tbody></table>

<aside class="notice"> The <b>ArrayConf</b> struct is not modified by <b>array_new_conf</b>. All of its values are copied into the Array structure and no reference to it is stored in the Array structure, which means that the conf struct can be reused for creating other arrays.</aside>

<h2 id="array_destroy">array_destroy</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">s</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">);</span>

<span class="p">...</span>


<span class="n">array_destroy</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>

</code></pre>

<p>Arrays can be destroyed by passing a pointer of the Array structure to <code class="prettyprint">array_destroy</code>. The Array structure is freed using the <code class="prettyprint">mem_free</code> function that is specified during Array creation.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void array_destroy(Array*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to an array that is to be destroyed</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<h2 id="array_destroy_free">array_destroy_free</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">s</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>

<span class="p">...</span>


<span class="n">array_destroy_free</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>

</code></pre>

<p>Destroying an Array along with all the data it holds can be done by calling  <code class="prettyprint">array_destroy_free</code> on a Array struct.</p>

<p>The Array structure and the contents are freed using the <code class="prettyprint">mem_free</code> function that is specified during Array creation.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void array_destroy_free(Array*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to an array that is to be destroyed</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<aside class="warning">When using this function make sure that the array doesn&rsquo;t contain any elements allocated on the stack.</aside>

<h2 id="array_add">array_add</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Add "foo" string to the array and check the return code
</span><span class="k">if</span> <span class="p">(</span><span class="n">array_add</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="c1">// something bad happened
</span>    <span class="p">...</span>

</code></pre>

<p>Adding elements to an array can be done via <code class="prettyprint">array_add</code> which appends the new element to the end of the Array, making it the element with the highest index. This function returns a status code to indicate success or failure.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_add(Array*, void*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to an array to which the element is being added</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Pointer to an element that is being added</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfully added to the array</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation for the new element failed</td>
</tr>
</tbody></table>

<h2 id="array_add_at">array_add_at</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Insert an element at index 0 and check for errors
</span><span class="k">if</span> <span class="p">(</span><span class="n">array_add_at</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="c1">// something bad happened
</span>    <span class="p">...</span>

</code></pre>

<p>Elements can be added to specific position within the array via <code class="prettyprint">array_add_at</code>. Which adds an element to a specific index while shifting all subsequent elements by one. </p>

<p>The element must be inserted at an already existing or an index that is <code class="prettyprint">highest-index + 1</code>. So that for example if the array&rsquo;s highest index is 5 you could insert at index 6 because that would append an element to the end of the array even though the index isn&rsquo;t occupied.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_add_at(Array*, void*, size_t)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to an array that is to be destroyed</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Pointer to an element that is being added</td>
</tr>
<tr>
<td>3</td>
<td>size_t</td>
<td>in</td>
<td>Index at which the element is to be added</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfully added to the array</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation for the new element failed</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>If the index is out of range</td>
</tr>
</tbody></table>

<h2 id="array_replace_at">array_replace_at</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Replace an element at index 3 with "foo" and store the old value at 'replaced'
</span><span class="kt">void</span> <span class="o">*</span><span class="n">replaced</span><span class="p">;</span>
<span class="n">array_replace_at</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">replaced</span><span class="p">);</span>

<span class="c1">// Replace an element at index 10 but ignore the old value
</span><span class="n">array_replace_at</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

</code></pre>

<p>Existing elements can be replaced with <code class="prettyprint">array_replace_at</code>.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_replace_at(Array*, void*, size_t, void **)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to an array that is to be destroyed</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Pointer to a replacement element</td>
</tr>
<tr>
<td>3</td>
<td>size_t</td>
<td>in</td>
<td>Index of the replaced element</td>
</tr>
<tr>
<td>4</td>
<td>void**</td>
<td>out</td>
<td>Pointer at which the replaced element is stored. Can be NULL if you wish to ignore it.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfully replaced</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>If the index is out of range</td>
</tr>
</tbody></table>

<h2 id="array_remove">array_remove</h2>
<pre class="highlight c"><code><span class="c1">//remove an element foo and ignore the output parameter
</span><span class="n">array_remove</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">foo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// remove the element bar and save the removed value to 'rm'
</span><span class="kt">void</span> <span class="o">*</span><span class="n">rm</span><span class="p">;</span>
<span class="n">array_remove</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rm</span><span class="p">);</span>
</code></pre>

<p>Removing an element by reference can be done via <code class="prettyprint">array_remove</code> which removes the element and optionally returns the removed element through an output parameter. </p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_remove(Array*, void *, void **)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Element that is being removed</td>
</tr>
<tr>
<td>3</td>
<td>void**</td>
<td>out</td>
<td>Pointer to an output variable where the removed element should be saved. This can be set to NULL if you wish to ignore the removed element.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfully removed</td>
</tr>
<tr>
<td>CC_ERR_VALUE_NOT_FOUND</td>
<td>If the element was not found</td>
</tr>
</tbody></table>

<h2 id="array_remove_at">array_remove_at</h2>
<pre class="highlight c"><code><span class="c1">//remove an element at index 3 and ignore the output parameter
</span><span class="n">array_remove_at</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// remove the element at index 10 and save the removed value to 'rm'
</span><span class="kt">void</span> <span class="o">*</span><span class="n">rm</span><span class="p">;</span>
<span class="n">array_remove_at</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rm</span><span class="p">);</span>
</code></pre>

<p>Removing array elements at a specific index can be done via <code class="prettyprint">array_remove_at</code> which removes the element at the specified index and returns it through the output parameter.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_remove(Array*, size_t, void **)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
<tr>
<td>2</td>
<td>size_t</td>
<td>in</td>
<td>Element that is being removed</td>
</tr>
<tr>
<td>3</td>
<td>void**</td>
<td>out</td>
<td>Pointer to an output variable where the removed element should be saved. This can be set to NULL if you wish to ignore the removed element.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfully removed</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>If the index was out of range</td>
</tr>
</tbody></table>

<h2 id="array_remove_last">array_remove_last</h2>
<pre class="highlight c"><code><span class="n">array_remove_last</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre>

<p>Elements can be removed from the last position, or the one with the highest index, via <code class="prettyprint">array_remove_last</code>. This function has the same effect as calling <code class="prettyprint">array_remove_at</code> with the highest index.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_remove_last(Array*, void **)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
<tr>
<td>2</td>
<td>void**</td>
<td>out</td>
<td>Element that is being removed</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfully removed</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>If the index was out of range</td>
</tr>
</tbody></table>

<h2 id="array_remove_all">array_remove_all</h2>
<pre class="highlight c"><code><span class="n">array_remove_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">);</span>
</code></pre>

<p>The array can be cleared with <code class="prettyprint">array_remove_all</code>. This function does not shrink the underlying buffer.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void array_remove_all(Array*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<h2 id="array_remove_all_free">array_remove_all_free</h2>
<pre class="highlight c"><code><span class="n">array_remove_all_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">);</span>
</code></pre>

<p>Removes and frees all elements from the specified array. This function does not shrink the array capacity.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void array_remove_all_free()</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<h2 id="array_get_at">array_get_at</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Retrieve the element from index 5 and store it in 'e'
</span><span class="kt">void</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">array_get_at</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="c1">// something bad happened
</span>    <span class="p">...</span>
</code></pre>

<p>Returns an array element from the specified index. The specified index must be within the bounds of the array.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_get_at(Array*, size_t, void**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
<tr>
<td>2</td>
<td>size_t</td>
<td>in</td>
<td>Index into the array</td>
</tr>
<tr>
<td>3</td>
<td>void**</td>
<td>out</td>
<td>Pointer to a void* to which the element is saved</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfully retrieved</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>If the index was out of range</td>
</tr>
</tbody></table>

<h2 id="array_get_last">array_get_last</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Retrieve the last element of the array
</span><span class="kt">void</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">array_get_last</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="c1">// something bad happened
</span>    <span class="p">...</span>
</code></pre>

<p>Returns the last element of the array, or the element with the highest index,
if the array is not empty.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_get_last(Array*, void**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
<tr>
<td>2</td>
<td>void**</td>
<td>out</td>
<td>Pointer to a void* to which the element is saved</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfully retrieved</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>If the array is empty</td>
</tr>
</tbody></table>

<h2 id="array_index_of">array_index_of</h2>
<pre class="highlight c"><code><span class="kt">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">array_index_of</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="c1">// something bad happened
</span>    <span class="p">...</span>
</code></pre>

<p>Returns the index of the first occurrence of the specified array element, or <code class="prettyprint">CC_ERR_OUT_OF_RANGE</code> if the element could not be found.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_index_of(Array*, void*, size_t*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Element whose index is being looked up</td>
</tr>
<tr>
<td>3</td>
<td>size_t*</td>
<td>out</td>
<td>Pointer to the index variable</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the index of the element was found</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>if the element was not found</td>
</tr>
</tbody></table>

<h2 id="array_subarray">array_subarray</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">status</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="p">...</span>

<span class="p">...</span>

<span class="n">Array</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">array_subarray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sub</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="p">...</span>

</code></pre>

<p>Creates a sub-array of the specified array, ranging from <code class="prettyprint">b</code> inclusive to <code class="prettyprint">e</code> inclusive. The range indices must be within the bounds of the array, while the e index must be greater or equal to the <code class="prettyprint">b</code> index, otherwise this operation will fail.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_subarray(Array*, size_t, size_t, Array**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
<tr>
<td>2</td>
<td>size_t</td>
<td>in</td>
<td>The beginning index (inclusive) of the sub-array. Must be within the bounds of the array and must not exceed the end index.</td>
</tr>
<tr>
<td>3</td>
<td>size_t</td>
<td>in</td>
<td>The end index (inclusive) of the sub-array. Must be within the bounds of the array and must be greater or equal to the beginning index.</td>
</tr>
<tr>
<td>4</td>
<td>Array**</td>
<td>out</td>
<td>The pointer to where the sub array pointer is stored.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the sub-array was successfully created</td>
</tr>
<tr>
<td>CC_ERR_INVALID_RANGE</td>
<td>If the specified range is invalid</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if the allocation for the new sub array failed.</td>
</tr>
</tbody></table>

<aside class="notice">The new sub-array is allocated using the original array&rsquo;s allocators. It also inherits the configuration of the original array.</aside>

<h2 id="array_copy_shallow">array_copy_shallow</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">status</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Make a shallow
</span><span class="n">Array</span> <span class="o">*</span><span class="n">copy</span><span class="p">;</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">array_copy_shallow</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copy</span><span class="p">);</span>

</code></pre>

<p>Creates a shallow copy of the specified array. A shallow copy is a copy of the array structure, but not the elements it holds.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_copy_shallow(Array*, Array**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
<tr>
<td>2</td>
<td>Array**</td>
<td>out</td>
<td>The pointer to where the copy array pointer is stored.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the copy was successfully created</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if the allocation for the new copy array failed.</td>
</tr>
</tbody></table>

<aside class="notice">The new array is allocated using the original array&rsquo;s allocators. It also inherits the configuration of the original array.</aside>

<h2 id="array_copy_deep">array_copy_deep</h2>
<pre class="highlight c"><code>
<span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">status</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Copy function
</span><span class="kt">void</span> <span class="o">*</span><span class="n">cp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span> <span class="n">val</span><span class="p">);</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">));</span>
    <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="c1">// Make a shallow
</span><span class="n">Array</span> <span class="o">*</span><span class="n">copy</span><span class="p">;</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">array_copy_deep</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copy</span><span class="p">);</span>

</code></pre>

<p>Creates a deep copy of the specified array. A deep copy is a copy of the array structure and the data it holds.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_copy_deep(Array*, void *(*) (void*), Array**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to the array</td>
</tr>
<tr>
<td>2</td>
<td><code class="prettyprint">void *(*) (void*)</code></td>
<td>in</td>
<td>Pointer to the copy function</td>
</tr>
<tr>
<td>3</td>
<td>Array**</td>
<td>out</td>
<td>The pointer to where the copy array pointer is stored.</td>
</tr>
</tbody></table>

<h3 id="copy-function">Copy function</h3>

<p>Takes a pointer to a value and returns a pointer to a copy of that value.</p>

<p><code class="prettyprint">void *cp(void*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>void*</td>
<td>in</td>
<td>Pointer to the element that is to be copied</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the copy was successfully created</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if the allocation for the new copy array failed.</td>
</tr>
</tbody></table>

<aside class="notice">The new array is allocated using the original array&rsquo;s allocators. It also inherits the configuration of the original array.</aside>

<h2 id="array_reverse">array_reverse</h2>
<pre class="highlight c"><code><span class="n">array_reverse</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
</code></pre>

<p>Reverses the order of elements in the specified array.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void array_reverse(Array*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Array to be reversed</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<h2 id="array_trim_capacity">array_trim_capacity</h2>
<pre class="highlight c"><code><span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">status</span> <span class="o">=</span> <span class="n">array_trim_capacity</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="p">...</span>
</code></pre>

<p>Trims the array&rsquo;s capacity to match the number of elements. The capacity can never shrink below 1.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_trim_capacity(Array*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Array whose capacity is being trimmed</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the capacity was trimmed successfully</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if the allocation for the new capacity failed.</td>
</tr>
</tbody></table>

<h2 id="array_contains">array_contains</h2>
<pre class="highlight c"><code><span class="kt">size_t</span> <span class="n">e</span> <span class="o">=</span> <span class="n">array_contains</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span>
</code></pre>

<p>Returns the number of occurrences of the element within the array.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">size_t array_contains(Array *ar, void *element)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Array that is being searched</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">size_t</code></p>

<p>The number of matches.</p>

<h2 id="array_size">array_size</h2>
<pre class="highlight c"><code><span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">array_size</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
</code></pre>

<p>Returns the size of the array. The size is the number of elements that the array holds.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">size_t array_size(Array*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Array whose size is being returned</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">size_t</code></p>

<p>The number of elements.</p>

<h2 id="array_capacity">array_capacity</h2>
<pre class="highlight c"><code><span class="kt">size_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">array_capacity</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
</code></pre>

<p>Returns the capacity of the array. The capacity of the array is the current size of it&rsquo;s internal buffer.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">size_t array_capacity(Array*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Array whose capacity is being returned</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">size_t</code></p>

<p>The capacity of the array.</p>

<h2 id="array_sort">array_sort</h2>
<pre class="highlight c"><code><span class="c1">// compare function
</span><span class="kt">int</span> <span class="nf">mycmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">e1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">e2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MyType</span> <span class="n">el1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">MyType</span><span class="o">**</span><span class="p">)</span> <span class="n">e1</span><span class="p">));</span>
    <span class="n">MyType</span> <span class="n">el2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">MyType</span><span class="o">**</span><span class="p">)</span> <span class="n">e2</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">el1</span> <span class="o">&lt;</span> <span class="n">el2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">el1</span> <span class="o">&gt;</span> <span class="n">el2</span><span class="p">)</span> <span class="k">return</span>  <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="c1">// sort the array with the compare function
</span><span class="n">array_sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mycmp</span><span class="p">);</span>

</code></pre>

<p>Sorts the array.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void array_sort(Array*, int (*) (const void*, const void*))</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Array that is being sorted</td>
</tr>
<tr>
<td>2</td>
<td><code class="prettyprint">int (*) (const void*, const void*)</code></td>
<td>in</td>
<td>Compare function. Returns &lt; 0 if the first element goes before the second, 0 if the elements are equal and &gt; 0 if the second elements goes before the first.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<aside class="notice"> Pointers passed to the compare function will be pointers to pointers since array elements are already pointers. This means that an extra step of dereferencing will be required before the elements can be compared</aside>

<h2 id="array_map">array_map</h2>
<pre class="highlight c"><code>
<span class="kt">void</span> <span class="nf">fn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="c1">// Adds 10 to each element
</span><span class="n">array_map</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>

</code></pre>

<p>Maps a function over each element of the array.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void array_map(Array*, void (*) (void*))</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Array over which the function is mapped</td>
</tr>
<tr>
<td>2</td>
<td><code class="prettyprint">void (*)(void*)</code></td>
<td>in</td>
<td>Function that is to be called on each element</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<h2 id="arrayiter">ArrayIter</h2>
<pre class="highlight c"><code><span class="c1">// Array iterator
</span><span class="n">ArrayIter</span> <span class="n">ai</span><span class="p">;</span>

<span class="c1">// Initialize the iterator
</span><span class="n">array_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>
</code></pre>

<p>Array iterator struct. Used to iterate over elements of the array in an ascending order. The iterator is initialized with <code class="prettyprint">array_iter_init</code> which initializes the iterator with a specific array.</p>

<h2 id="array_iter_next">array_iter_next</h2>
<pre class="highlight c"><code><span class="n">ArrayIter</span> <span class="n">ai</span><span class="p">;</span>
<span class="n">array_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">array_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_ITER_END</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

</code></pre>

<p>Advances the iterator and returns the next element in the sequence if more elements exist.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_iter_next(ArrayIter*, void**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>ArrayIter*</td>
<td>in</td>
<td>The array iterator</td>
</tr>
<tr>
<td>2</td>
<td>void**</td>
<td>out</td>
<td>The next element in the sequence</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if an element was returned</td>
</tr>
<tr>
<td>CC_ITER_END</td>
<td>if there are no more elements in the sequence</td>
</tr>
</tbody></table>

<h2 id="array_iter_remove">array_iter_remove</h2>
<pre class="highlight c"><code><span class="n">ArrayIter</span> <span class="n">ai</span><span class="p">;</span>
<span class="n">array_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">array_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_ITER_END</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// safely remove an element from the array and ignore the removed value
</span>        <span class="n">array_iter_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Removes the last returned element by <code class="prettyprint">array_iter_next</code> without invalidating the iterator.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_iter_remove(ArrayIter*, void**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>ArrayIter*</td>
<td>in</td>
<td>The array iterator</td>
</tr>
<tr>
<td>2</td>
<td>void**</td>
<td>out</td>
<td>Pointer to where the removed element should be saved. This can be set to NULL if you wish to ignore the removed element.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if an element was removed successfully</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>if the element was out of range. This should never be returned if the iterator is used properly.</td>
</tr>
</tbody></table>

<h2 id="array_iter_add">array_iter_add</h2>
<pre class="highlight c"><code><span class="n">ArrayIter</span> <span class="n">ai</span><span class="p">;</span>
<span class="n">array_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">array_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_ITER_END</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// safely add an element
</span>        <span class="n">array_iter_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Adds a new element to the array  after the last returned element by <code class="prettyprint">array_iter_next</code>, without invalidating the iterator.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_iter_add(ArrayIter*, void*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>ArrayIter*</td>
<td>in</td>
<td>The array iterator</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>The element that is being added.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if an element was added successfully</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if the memory allocation for the new element failed.</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>if the element was out of range. This should never be returned if the iterator is used properly.</td>
</tr>
</tbody></table>

<h2 id="array_iter_replace">array_iter_replace</h2>
<pre class="highlight c"><code><span class="n">ArrayIter</span> <span class="n">ai</span><span class="p">;</span>
<span class="n">array_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">array_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_ITER_END</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">array_iter_replace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Replaces the last returned element by <code class="prettyprint">array_iter_next</code> with the specified element.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_iter_replace(ArrayIter*, void*, void**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>ArrayIter*</td>
<td>in</td>
<td>The array iterator</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>The replacement element.</td>
</tr>
<tr>
<td>3</td>
<td>void**</td>
<td>out</td>
<td>Pointer to where the replaced element should be stored. This can be set to NULL if you wish to ignore the replaced element.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if an element was replaced successfully</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>if the element was out of range. This should never be returned if the iterator is used properly.</td>
</tr>
</tbody></table>

<h2 id="array_iter_index">array_iter_index</h2>
<pre class="highlight c"><code><span class="n">ArrayIter</span> <span class="n">ai</span><span class="p">;</span>
<span class="n">array_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">array_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_ITER_END</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">array_iter_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ai</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>

<p>Returns the index of the last returned element by <code class="prettyprint">array_iter_next</code>.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">size_t array_iter_index(ArrayIter*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>ArrayIter*</td>
<td>in</td>
<td>The array iterator</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">size_t</code></p>

<p>The iterator index.</p>

          <h1 id="hashtable">HashTable</h1>

<h2 id="hashtable_new">hashtable_new</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

<span class="c1">// Create a new string key table
</span><span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">status</span> <span class="o">=</span> <span class="n">hashtable_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>

<span class="c1">// Check if the HashTable was initialized correctly
</span><span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">CC_ERR_ALLOC</span><span class="p">)</span>
    <span class="p">...</span>
</code></pre>

<p>New hash tables can be created with <code class="prettyprint">hashtable_new</code>. This will create a new empty hash table with default parameters. Hash tables created this way will work with <strong>string keys</strong>.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat hashtable_new(HashTable**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTable**</td>
<td>out</td>
<td>Pointer to a HashTable that is being initialized</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the HashTable was successfully initialized</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation failed</td>
</tr>
</tbody></table>

<h2 id="hashtableconf">HashTableConf</h2>

<blockquote>
<p>Configuring a new HashTable to use pointer values as keys</p>
</blockquote>
<pre class="highlight c"><code><span class="n">HashTableConf</span> <span class="n">htc</span><span class="p">;</span>

<span class="c1">// Initialize all fields to default values
</span><span class="n">hashtable_conf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htc</span><span class="p">);</span>

<span class="c1">// Configure the HashTable to work with pointer keys
</span><span class="n">htc</span><span class="p">.</span><span class="n">hash</span>        <span class="o">=</span> <span class="n">POINTER_HASH</span><span class="p">;</span>
<span class="n">htc</span><span class="p">.</span><span class="n">key_length</span>  <span class="o">=</span> <span class="n">KEY_LENGTH_POINTER</span><span class="p">;</span>
<span class="n">htc</span><span class="p">.</span><span class="n">key_compare</span> <span class="o">=</span> <span class="n">CMP_POINTER</span><span class="p">;</span>

<span class="c1">// Create a new HashTable with pointer keys
</span><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hashtable_new_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// use the pointer value itself as a key
</span><span class="n">hashtable_add</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="mi">42</span><span class="p">,</span> <span class="s">"answertolifeuniverseandeverything"</span><span class="p">)</span>
</code></pre>

<blockquote>
<p>Configuring a new HashTable to use values at pointers as keys</p>
</blockquote>
<pre class="highlight c"><code>
<span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">bool</span> <span class="nf">foo_compare</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">f1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">f2</span><span class="p">)</span> <span class="p">{...}</span>

<span class="p">...</span>

<span class="n">HashTableConf</span> <span class="n">htc</span><span class="p">;</span>

<span class="c1">// Initialize all fields to default values
</span><span class="n">hashtable_conf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htc</span><span class="p">);</span>

<span class="c1">// Configure the HashTable to work with values
</span><span class="n">htc</span><span class="p">.</span><span class="n">hash</span>        <span class="o">=</span> <span class="n">GENERAL_HASH</span><span class="p">;</span>
<span class="n">htc</span><span class="p">.</span><span class="n">key_length</span>  <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo</span><span class="p">);</span>
<span class="n">htc</span><span class="p">.</span><span class="n">key_compare</span> <span class="o">=</span> <span class="n">foo_compare</span><span class="p">;</span>

<span class="c1">// Create a new HashTable with `struct foo` keys
</span><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hashtable_new_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">foo</span> <span class="n">f1</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">struct</span> <span class="n">foo</span> <span class="n">f2</span> <span class="o">=</span> <span class="p">...;</span>

<span class="c1">// use `struct foo` values as keys
</span><span class="n">hashtable_add</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f1</span><span class="p">,</span> <span class="s">"somevalue"</span><span class="p">);</span>
<span class="n">hashtable_add</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f2</span><span class="p">,</span> <span class="s">"someothervalue"</span><span class="p">);</span>

</code></pre>

<blockquote>
<p>Configuring a new HashTable to use string keys (this has the same effect as creating the table with &lsquo;hasthable_new()&rsquo;)</p>
</blockquote>
<pre class="highlight c"><code><span class="n">HashTableConf</span> <span class="n">htc</span><span class="p">;</span>

<span class="c1">// Initialize all fields to default values
</span><span class="n">hashtable_conf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htc</span><span class="p">);</span>

<span class="c1">// Configure the HashTable to work with string keys
</span><span class="n">htc</span><span class="p">.</span><span class="n">hash</span>        <span class="o">=</span> <span class="n">STRING_HASH</span><span class="p">;</span>
<span class="n">htc</span><span class="p">.</span><span class="n">key_length</span>  <span class="o">=</span> <span class="n">KEY_LENGTH_VARIABLE</span><span class="p">;</span>
<span class="n">htc</span><span class="p">.</span><span class="n">key_compare</span> <span class="o">=</span> <span class="n">CMP_STRING</span><span class="p">;</span>

<span class="c1">// Create a new HashTable with string keys
</span><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hashtable_new_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="n">hashtale_add</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">);</span>

</code></pre>

<p>HashTableConf struct lets you pass additional parameters when creating a new HashTable.</p>

<h3 id="struct">Struct</h3>

<p><code class="prettyprint">HashTableConf</code></p>

<table><thead>
<tr>
<th>field</th>
<th>type</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>load_factor</td>
<td>float</td>
<td>Load factor determines when the underlying table buffer grows. For example if the load factor is 0.5 and the internal buffer capacity is 100, the resize will be triggered once the 50Th entry is added.</td>
</tr>
<tr>
<td>initial_capacity</td>
<td>size_t</td>
<td>The initial capacity of the table (rounded to power of two)</td>
</tr>
<tr>
<td>key_length</td>
<td>int</td>
<td>The length of the key. This should be set to -1 if the keys are of variable length.</td>
</tr>
<tr>
<td>hash_seed</td>
<td>uint32_t</td>
<td>Hash function seed</td>
</tr>
<tr>
<td>hash</td>
<td><code class="prettyprint">size_t (*) (const void *, int, uint32_t)</code></td>
<td>The hash function which takes an <code class="prettyprint">const void*</code> key,<code class="prettyprint">int</code> key length and a <code class="prettyprint">uint32_t</code> seed and returns a hash of <code class="prettyprint">size_t</code> size.</td>
</tr>
<tr>
<td>key_compare</td>
<td><code class="prettyprint">bool (*) (void*, void*)</code></td>
<td>key comparator function which returns true if the keys are identical</td>
</tr>
<tr>
<td>mem_alloc</td>
<td>void <em>(</em>) (size_t)</td>
<td>Pointer to a user specified &ldquo;malloc&rdquo;</td>
</tr>
<tr>
<td>mem_calloc</td>
<td>void*(*) (size_t, size_t)</td>
<td>Pointer to a user specified &ldquo;calloc&rdquo;</td>
</tr>
<tr>
<td>mem_free</td>
<td>void (<em>) (void</em>)</td>
<td>Pointer to a user specified &ldquo;free&rdquo;</td>
</tr>
</tbody></table>

<h3 id="definitions-in-hashtable-h">Definitions in hashtable.h</h3>

<p>Hash functions:</p>

<table><thead>
<tr>
<th>definition</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>STRING_HASH</td>
<td>String hash function</td>
</tr>
<tr>
<td>GENERAL_HASH</td>
<td>General hash function that hashes the data at the pointer.</td>
</tr>
<tr>
<td>POINTER_HASH</td>
<td>Hash function which hashes the pointer itself.</td>
</tr>
<tr>
<td>KEY_LENGTH_VARIABLE</td>
<td>Variable key length (used with string keys)</td>
</tr>
</tbody></table>

<aside class="warning"> Make sure that all fields are initialized before passing it to <b>hashtable_new_conf()</b> either by manually setting each field or by initializing the struct with <b>hashtable_conf_init()</b>. </aside>

<h2 id="hashtable_new_conf">hashtable_new_conf</h2>
<pre class="highlight c"><code><span class="n">HashTableConf</span> <span class="n">htc</span><span class="p">;</span>

<span class="c1">// Initialize all fields to default values
</span><span class="n">hashtable_conf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htc</span><span class="p">);</span>

<span class="c1">// Configure the HashTable to work with pointer keys
</span><span class="n">htc</span><span class="p">.</span><span class="n">hash</span>        <span class="o">=</span> <span class="n">POINTER_HASH</span><span class="p">;</span>
<span class="n">htc</span><span class="p">.</span><span class="n">key_length</span>  <span class="o">=</span> <span class="n">KEY_LENGTH_POINTER</span><span class="p">;</span>
<span class="n">htc</span><span class="p">.</span><span class="n">key_compare</span> <span class="o">=</span> <span class="n">CMP_POINTER</span><span class="p">;</span>

<span class="c1">// Create a new HashTable with pointer keys
</span><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hashtable_new_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>

<p>HashTables can be created with additional parameters by calling <code class="prettyprint">hashtable_new_conf</code> instead of <code class="prettyprint">hashtable_new</code>. The <code class="prettyprint">hashtable_new_conf</code> function takes a pointer to a <code class="prettyprint">HashTableConf</code> struct and a pointer to a pointer to a HashTable structure. <code class="prettyprint">hashtable_new_conf</code> returns a status code to indicate success or failure.</p>

<p>The HashTable is allocated using the allocators passed in by <code class="prettyprint">HashTableConf</code>. These allocators are used for all future operations on this table structure.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat hashtable_new_conf(HashTableConf*, HashTable**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>const HashTableConf const*</td>
<td>in</td>
<td>Pointer to a config struct</td>
</tr>
<tr>
<td>2</td>
<td>HashTable**</td>
<td>out</td>
<td>Pointer to an table that is being initialized</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the table was successfully initialized</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation failed</td>
</tr>
</tbody></table>

<h2 id="hashtable_destroy">hashtable_destroy</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">s</span> <span class="o">=</span> <span class="n">hashtable_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>

<span class="p">...</span>

<span class="n">hashtable_destroy</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
</code></pre>

<p>Destroys the HashTable structure.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void hashtable_destroy(HashTable*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTable*</td>
<td>in</td>
<td>Pointer to a table that is to be destroyed</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<h2 id="hashtable_add">hashtable_add</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">hashtable_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>

<span class="p">...</span>

<span class="k">if</span> <span class="p">(</span><span class="n">hashtable_add</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// something bad happened
</span>    <span class="p">...</span>
<span class="p">}</span>
</code></pre>

<p>Adding new key-value mappings to a HashTable can be done via <code class="prettyprint">hashtable_add</code>. If the key is already mapped to a value in the table, that value is replaced with the new value.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat hashtable_add(HashTable*, void*, void*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTable*</td>
<td>in</td>
<td>Pointer to a table that is to be destroyed</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Pointer to a key, or a NULL key</td>
</tr>
<tr>
<td>3</td>
<td>void*</td>
<td>in</td>
<td>Pointer to a value</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the mapping was successfully added to the table</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation for the new mapping failed</td>
</tr>
</tbody></table>

<h2 id="hashtable_get">hashtable_get</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// Retrieve the value mapped to key "foo"
</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hashtable_get</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// something went wrong
</span>    <span class="p">...</span>
<span class="p">}</span>

</code></pre>

<p>Gets a value associated with the specified key. If there is not value associated with the key, <code class="prettyprint">CC_ERR_KEY_NOT_FOUND</code> is returned and the output is not set.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat hashtable_get(HashTable*, void*, void**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTable*</td>
<td>in</td>
<td>Pointer to the table</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Table key</td>
</tr>
<tr>
<td>3</td>
<td>void**</td>
<td>out</td>
<td>Pointer to a <code class="prettyprint">void*</code> to which the value is saved</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the value was successfully retrieved</td>
</tr>
<tr>
<td>CC_ERR_KEY_NOT_FOUND</td>
<td>If the key doesn&rsquo;t exist</td>
</tr>
</tbody></table>

<h2 id="hashtable_remove">hashtable_remove</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

<span class="p">...</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">removed</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">hashtable_remove</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">removed</span><span class="p">);</span>

</code></pre>

<p>Removes a key-value mapping from the specified table. In case the key doesn&rsquo;t exist, <code class="prettyprint">CC_ERR_KEY_NOT_FOUND</code> is returned.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat hashtable_remove(HashTable*, void*, void**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTable*</td>
<td>in</td>
<td>Pointer to the table</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Key</td>
</tr>
<tr>
<td>3</td>
<td>void**</td>
<td>out</td>
<td>Pointer to an output variable where the removed value should be saved. This can be set to NULL if you wish to ignore the removed value.</td>
</tr>
</tbody></table>

<h2 id="hashtable_remove_all">hashtable_remove_all</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// clears the table
</span><span class="n">hashtable_remove_all</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
</code></pre>

<p>Removes all key-value mappings from the table</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void hashtable_remove_all(HashTable*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTable*</td>
<td>in</td>
<td>Pointer to the table</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<h2 id="hashtable_contains_key">hashtable_contains_key</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// check if the table contains the key "foo"
</span><span class="k">if</span> <span class="p">(</span><span class="n">hashtable_contains_key</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>

<p>Checks whether or not the table contains the specified key</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">bool hashtable_contains_key(HashTable*, void*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTable*</td>
<td>in</td>
<td>Pointer to the table</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>key that is being looked up</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">bool</code></p>

<table><thead>
<tr>
<th>value</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>true</td>
<td>if the key exists</td>
</tr>
<tr>
<td>false</td>
<td>if the key doesn&rsquo;t exist</td>
</tr>
</tbody></table>

<h2 id="hashtable_size">hashtable_size</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// get the number of key-value mappings in the table
</span><span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">hashtable_size</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>

</code></pre>

<p>Returns the number of key-value mapping in the table.</p>

<h3 id="function">Function</h3>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTable*</td>
<td>in</td>
<td>Pointer to the table</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">size_t</code></p>

<h2 id="hashtable_capacity">hashtable_capacity</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

<span class="p">...</span>

<span class="kt">size_t</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">hashtable_capacity</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
</code></pre>

<p>Returns the current capacity of the table. The capacity represents the size of the internal table buffer.</p>

<h3 id="function">Function</h3>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTable*</td>
<td>in</td>
<td>Pointer to the table</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">size_t</code></p>

<h2 id="hashtableiter">HashTableIter</h2>
<pre class="highlight c"><code><span class="n">HashTableIter</span> <span class="n">hti</span><span class="p">;</span>

<span class="c1">// Initialize the iterator
</span><span class="n">hashtable_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hti</span><span class="p">);</span>
</code></pre>

<p>HashTable iterator struct used to iterate over table entries. The iterator is initalized with <code class="prettyprint">array_iter_init</code>.</p>

<h2 id="tableentry">TableEntry</h2>

<h3 id="struct">Struct</h3>

<table><thead>
<tr>
<th>field</th>
<th>type</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>key</td>
<td>void*</td>
<td>Table key</td>
</tr>
<tr>
<td>value</td>
<td>void*</td>
<td>Value mapped to the key</td>
</tr>
<tr>
<td>hash</td>
<td>size_t</td>
<td>Hash of the key</td>
</tr>
</tbody></table>

<h2 id="hashtable_iter_next">hashtable_iter_next</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">HashTableIter</span> <span class="n">hti</span><span class="p">;</span>
<span class="n">hashtable_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hti</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>

<span class="n">TableEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">array_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hti</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_ITER_END</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>

<p>Advances the iterator and gets the next entry if it exists.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_enum hashtable_iter_next(HashTableIter*, TableEntry**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTableIter*</td>
<td>in</td>
<td>The table iterator</td>
</tr>
<tr>
<td>2</td>
<td>TableEntry**</td>
<td>out</td>
<td>Pointer to where the next entry is set</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if an entry was returned</td>
</tr>
<tr>
<td>CC_ITER_END</td>
<td>if there are no more entries</td>
</tr>
</tbody></table>

<h2 id="hashtable_iter_remove">hashtable_iter_remove</h2>
<pre class="highlight c"><code><span class="n">HashTable</span> <span class="o">*</span><span class="n">table</span>

<span class="p">...</span>

<span class="n">HashTableIter</span> <span class="n">hti</span><span class="p">;</span>
<span class="n">hashtable_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hti</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>

<span class="n">TableEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">hashtable_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hti</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_ITER_END</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// safely remove an entry from the table and ignore the removed value
</span>        <span class="n">hashtable_iter_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hti</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Removes the last returned entry by <code class="prettyprint">hashtable_iter_next</code> without invalidating the iterator.</p>

<h3 id="function">Function</h3>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>HashTableIter*</td>
<td>in</td>
<td>The table iterator</td>
</tr>
<tr>
<td>2</td>
<td>void**</td>
<td>out</td>
<td>Pointer to where the removed value should be saved. This can be set to NULL if you wish to ignore the removed value.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if an value was removed successfully</td>
</tr>
<tr>
<td>CC_ERR_KEY_NOT_FOUND</td>
<td>if the key was not found. This should never be returned if the iterator is used properly.</td>
</tr>
</tbody></table>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="c">c</a>
          </div>
      </div>
    </div>
  </body>
</html>
