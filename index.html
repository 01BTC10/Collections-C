<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;c&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" />
        <div class="lang-selector">
              <a href="#" data-language-name="c">c</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='https://github.com/tripit/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>Welcome to the Collections C documentation.</p>

          <h1 id="array">Array</h1>

<h2 id="creating-a-new-array">Creating a new Array</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">status</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>


<span class="c1">// Check if the array was initialized correctly
</span><span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">CC_ERR_ALLOC</span><span class="p">)</span>
    <span class="p">...</span>
</code></pre>

<p>New arrays can be created with <code class="prettyprint">array_new</code>. This will create a new empty array with default parameters. <code class="prettyprint">array_new</code> takes a pointer to a pointer to an Array structure and initializes it with the new Array and then returns a status code to indicate success or failure. </p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_new(Array**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array**</td>
<td>out</td>
<td>Pointer to an array that is being initialized</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the array was successfully initialized</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation failed</td>
</tr>
</tbody></table>

<h2 id="array-configuration">Array configuration</h2>
<pre class="highlight c"><code><span class="n">ArrayConf</span> <span class="n">ac</span><span class="p">;</span>

<span class="c1">// Initialize all fields to default values
</span><span class="n">array_conf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>


<span class="c1">// change the default initial capacity
</span><span class="n">ac</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>


<span class="c1">// Now we can create a new array with an initial capacity of 100
</span><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">s</span> <span class="o">=</span> <span class="n">array_new_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>
</code></pre>

<p>ArrayConf struct lets you pass additional parameters when creating a new Array.</p>

<p>Perhaps you would like to initialize the array with a different initial capacity, or perhaps you might want to change the rate at which the array buffer grows. To do this you can pass a <code class="prettyprint">ArrayConf</code> struct to <code class="prettyprint">array_new_conf()</code> to get new customized Array.</p>

<p>To use the <code class="prettyprint">ArrayConf</code> struct we first initialize all of its fields to default values with <code class="prettyprint">array_conf_init(ArrayConf*)</code>, and then we overwrite individual fields that we&rsquo;re interested in.</p>

<p>If we simply passed <code class="prettyprint">ArrayConf</code> to <code class="prettyprint">array_conf_new()</code> after initializing it with <code class="prettyprint">array_conf_init</code> without changing any values, it would have the same effect as calling <code class="prettyprint">array_new()</code> without using the configuration struct.</p>

<h3 id="struct">Struct</h3>

<p><code class="prettyprint">ArrayConf</code></p>

<table><thead>
<tr>
<th>field</th>
<th>type</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>capacity</td>
<td>size_t</td>
<td>The initial capacity of the newly created array</td>
</tr>
<tr>
<td>exp_factor</td>
<td>float</td>
<td>The rate at which the internal buffer expands (capacity * exp_factor). For example if the exp_factor is set to 0.5, then the internal buffer would grow by 50% on each resize.</td>
</tr>
<tr>
<td>mem_alloc</td>
<td>void <em>(</em>) (size_t)</td>
<td>Pointer to a user specified &ldquo;malloc&rdquo;</td>
</tr>
<tr>
<td>mem_calloc</td>
<td>void*(*) (size_t, size_t)</td>
<td>Pointer to a user specified &ldquo;calloc&rdquo;</td>
</tr>
<tr>
<td>mem_free</td>
<td>void (<em>) (void</em>)</td>
<td>Pointer to a user specified &ldquo;free&rdquo;</td>
</tr>
</tbody></table>

<aside class="warning"> Make sure that all fields are initialized before passing it to <b>array_new_conf()</b> either by manually setting each field or by initializing the struct with <b>array_conf_init()</b>. </aside>

<h2 id="creating-an-array-with-parameters">Creating an array with parameters</h2>
<pre class="highlight c"><code><span class="n">ArrayConf</span> <span class="n">conf</span><span class="p">;</span>
<span class="n">array_conf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>

<span class="n">conf</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="n">conf</span><span class="p">.</span><span class="n">exp_factor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="n">f</span><span class="p">;</span>

<span class="c1">// Create a new array with with additional parameters
</span><span class="n">Array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">status</span> <span class="o">=</span> <span class="n">array_new_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>

<span class="c1">// Handle errors
</span><span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">CC_ERR_ALLOC</span><span class="p">)</span>
    <span class="p">...</span>

</code></pre>

<p>Arrays can be created with additional parameters by calling <code class="prettyprint">array_new_conf</code> instead of <code class="prettyprint">array_new</code>. The <code class="prettyprint">array_new_conf</code> function takes a pointer to a pointer to an Array structure and also a pointer to an <code class="prettyprint">ArrayConf</code> structure through which additional parameters are passed. <code class="prettyprint">array_new_conf</code> returns a status code to indicate success or failure.</p>

<p>The array is allocated using the allocators passed in by <code class="prettyprint">ArrayConf</code>.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_new_conf(const ArrayConf const*, Array**)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>const ArrayConf const*</td>
<td>in</td>
<td>Pointer to a config struct</td>
</tr>
<tr>
<td>2</td>
<td>Array**</td>
<td>out</td>
<td>Pointer to an array that is being initialized</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the array was successfully initialized</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation failed</td>
</tr>
<tr>
<td>CC_ERR_INVALID_CAPACITY</td>
<td>if the capacity in the <code class="prettyprint">ArrayConf</code> does not meet the following condition: <code class="prettyprint">exp_factor &lt; (CC_MAX_ELEMENTS / capacity)</code></td>
</tr>
</tbody></table>

<aside class="notice"> The <b>ArrayConf</b> struct is not modified by <b>array_new_conf</b>. All of its values are copied into the Array structure and no reference to it is stored in the Array structure, which means that the conf struct can be reused for creating other arrays.</aside>

<h2 id="destroying-arrays">Destroying arrays</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">s</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">);</span>

<span class="p">...</span>


<span class="n">array_destroy</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>

</code></pre>

<p>Arrays can be destroyed by passing a pointer of the Array structure to <code class="prettyprint">array_destroy</code>. The Array structure is freed using the <code class="prettyprint">mem_free</code> function that is specified during Array creation.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void array_destroy(Array*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>int</td>
<td>Pointer to an array that is to be destroyed</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<h2 id="destroying-arrays-and-elements">Destroying arrays and elements</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">s</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">);</span>

<span class="p">...</span>


<span class="n">array_destroy_free</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>

</code></pre>

<p>Destroying an Array along with all the data it holds can be done by calling  <code class="prettyprint">array_destroy_free</code> on a Array struct.</p>

<p>The Array structure and the contents are freed using the <code class="prettyprint">mem_free</code> function that is specified during Array creation.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">void array_destroy_free(Array*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to an array that is to be destroyed</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">void</code></p>

<aside class="warning">When using this function make sure that the array doesn&rsquo;t contain any elements allocated on the stack.</aside>

<h2 id="adding-an-element">Adding an element</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Add "foo" string to the array and check the return code
</span><span class="k">if</span> <span class="p">(</span><span class="n">array_add</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="c1">// someting bad happened
</span>    <span class="p">...</span>

</code></pre>

<p>Adding elements to an array can be done via <code class="prettyprint">array_add</code>. Which appends the new element to the end of the Array, making it the element with the highest index. This function returns a status code to indicate success or failure.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_add(Array*, void*)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to an array that is to be destroyed</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Pointer to an element that is being added</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfuly added to the array</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation for the new element failed</td>
</tr>
</tbody></table>

<h2 id="adding-element-at-specific-position">Adding element at specific position</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Insert an element at index 0 and check for errors
</span><span class="k">if</span> <span class="p">(</span><span class="n">array_add_at</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CC_OK</span><span class="p">)</span>
    <span class="c1">// something bad happened
</span>    <span class="p">...</span>

</code></pre>

<p>Elements can be added to specific position within the array via <code class="prettyprint">array_add_at</code>. Which adds an element to a specific index while shifting all subsequent elements by one. </p>

<p>The element must be inserted at an already existing or an index that is <code class="prettyprint">hightest-index + 1</code>. So that for example if the array&rsquo;s highest index is 5 you could insert at index 6 because that would append an element to the end of the array even though the index isn&rsquo;t occupied.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_add_at(Array*, void*, size_t)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to an array that is to be destroyed</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Pointer to an element that is being added</td>
</tr>
<tr>
<td>3</td>
<td>size_t</td>
<td>in</td>
<td>Index at which the element is to be added</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfuly added to the array</td>
</tr>
<tr>
<td>CC_ERR_ALLOC</td>
<td>if memory allocation for the new element failed</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>If the index is out of range</td>
</tr>
</tbody></table>

<h2 id="replacing-elements-at-specific-locations">Replacing elements at specific locations</h2>
<pre class="highlight c"><code><span class="n">Array</span> <span class="o">*</span><span class="n">ar</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">cc_stat</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Replace an element at index 3 with "foo" and store the old value at 'replaced'
</span><span class="kt">void</span> <span class="o">*</span><span class="n">replaced</span><span class="p">;</span>
<span class="n">array_replace_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">replaced</span><span class="p">);</span>

<span class="c1">// Replace an element at index 10 but ignore the old value
</span><span class="n">array_replace_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

</code></pre>

<p>Existing elements can be replaced with <code class="prettyprint">array_replace_at</code>.</p>

<h3 id="function">Function</h3>

<p><code class="prettyprint">enum cc_stat array_replace_at(Array*, void*, size_t, void **)</code></p>

<table><thead>
<tr>
<th>param</th>
<th>type</th>
<th>in/out</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>Array*</td>
<td>in</td>
<td>Pointer to an array that is to be destroyed</td>
</tr>
<tr>
<td>2</td>
<td>void*</td>
<td>in</td>
<td>Pointer to a replacement element</td>
</tr>
<tr>
<td>3</td>
<td>size_t</td>
<td>in</td>
<td>Index of the replaced element</td>
</tr>
<tr>
<td>4</td>
<td>void**</td>
<td>out</td>
<td>Pointer at which the replaced element is stored. Can be NULL if you wish to ignore it.</td>
</tr>
</tbody></table>

<h3 id="return">Return</h3>

<p><code class="prettyprint">enum cc_stat</code></p>

<table><thead>
<tr>
<th>code</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>CC_OK</td>
<td>if the element was successfuly replaced</td>
</tr>
<tr>
<td>CC_ERR_OUT_OF_RANGE</td>
<td>If the index is out of range</td>
</tr>
</tbody></table>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="c">c</a>
          </div>
      </div>
    </div>
  </body>
</html>
